#!/usr/bin/env bash

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !
# ! Note:
# !
# ! THIS SCRIPT HAS BEEN AUTOMATICALLY GENERATED USING
# ! swagger-codegen (https://github.com/swagger-api/swagger-codegen)
# ! FROM SWAGGER SPECIFICATION IN JSON.
# !
# ! Generated on: 2017-07-26T18:58:56.803+02:00
# !
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#
# This is a Bash client for Matrix Client-Server Client Config API.
#
# LICENSE:
# 
#
# CONTACT:
# 
#
# MORE INFORMATION:
# 
#

# For improved pattern matching in case statemets
shopt -s extglob

###############################################################################
#
# Make sure Bash is at least in version 4.3
#
###############################################################################
if ! ( (("${BASH_VERSION:0:1}" == "4")) && (("${BASH_VERSION:2:1}" >= "3")) ) \
  && ! (("${BASH_VERSION:0:1}" >= "5")); then
    echo ""
    echo "Sorry - your Bash version is ${BASH_VERSION}"
    echo ""
    echo "You need at least Bash 4.3 to run this script."
    echo ""
    exit 1
fi

###############################################################################
#
# Global variables
#
###############################################################################

##
# The filename of this script for help messages
script_name=`basename "$0"`

##
# Map for headers passed after operation as KEY:VALUE
declare -A header_arguments


##
# Map for operation parameters passed after operation as PARAMETER=VALUE
# These will be mapped to appropriate path or query parameters
# The values in operation_parameters are arrays, so that multiple values
# can be provided for the same parameter if allowed by API specification
declare -A operation_parameters

##
# Declare colors with autodection if output is terminal
if [ -t 1 ]; then
    RED="$(tput setaf 1)"
    GREEN="$(tput setaf 2)"
    YELLOW="$(tput setaf 3)"
    BLUE="$(tput setaf 4)"
    MAGENTA="$(tput setaf 5)"
    CYAN="$(tput setaf 6)"
    WHITE="$(tput setaf 7)"
    BOLD="$(tput bold)"
    OFF="$(tput sgr0)"
else
    RED=""
    GREEN=""
    YELLOW=""
    BLUE=""
    MAGENTA=""
    CYAN=""
    WHITE=""
    BOLD=""
    OFF=""
fi

declare -a result_color_table=( "$WHITE" "$WHITE" "$GREEN" "$YELLOW" "$WHITE" "$MAGENTA" "$WHITE" )

##
# This array stores the minimum number of required occurences for parameter
# 0 - optional
# 1 - required
declare -A operation_parameters_minimum_occurences
operation_parameters_minimum_occurences["casRedirect:::redirectUrl"]=1
operation_parameters_minimum_occurences["casTicket:::redirectUrl"]=1
operation_parameters_minimum_occurences["casTicket:::ticket"]=1
operation_parameters_minimum_occurences["deleteDevice:::deviceId"]=1
operation_parameters_minimum_occurences["deleteDevice:::body"]=0
operation_parameters_minimum_occurences["getDevice:::deviceId"]=1
operation_parameters_minimum_occurences["updateDevice:::deviceId"]=1
operation_parameters_minimum_occurences["updateDevice:::body"]=1
operation_parameters_minimum_occurences["claimKeys:::query"]=0
operation_parameters_minimum_occurences["downloadKeys:::query"]=0
operation_parameters_minimum_occurences["getChangedKeys:::from"]=1
operation_parameters_minimum_occurences["getChangedKeys:::to"]=1
operation_parameters_minimum_occurences["uploadKeys:::keys"]=0
operation_parameters_minimum_occurences["downloadMedia:::serverName"]=1
operation_parameters_minimum_occurences["downloadMedia:::mediaId"]=1
operation_parameters_minimum_occurences["downloadMediaFile:::serverName"]=1
operation_parameters_minimum_occurences["downloadMediaFile:::mediaId"]=1
operation_parameters_minimum_occurences["downloadMediaFile:::fileName"]=1
operation_parameters_minimum_occurences["downloadMediaThumbnail:::serverName"]=1
operation_parameters_minimum_occurences["downloadMediaThumbnail:::mediaId"]=1
operation_parameters_minimum_occurences["downloadMediaThumbnail:::width"]=0
operation_parameters_minimum_occurences["downloadMediaThumbnail:::height"]=0
operation_parameters_minimum_occurences["downloadMediaThumbnail:::method"]=0
operation_parameters_minimum_occurences["uploadMedia:::content"]=1
operation_parameters_minimum_occurences["uploadMedia:::Content-Type"]=0
operation_parameters_minimum_occurences["uploadMedia:::filename"]=0
operation_parameters_minimum_occurences["getPresenceList:::userId"]=1
operation_parameters_minimum_occurences["getPresenceStatus:::userId"]=1
operation_parameters_minimum_occurences["setPresenceList:::userId"]=1
operation_parameters_minimum_occurences["setPresenceList:::presence_diff"]=1
operation_parameters_minimum_occurences["setPresenceStatus:::userId"]=1
operation_parameters_minimum_occurences["setPresenceStatus:::presenceState"]=1
operation_parameters_minimum_occurences["deletePushRule:::scope"]=1
operation_parameters_minimum_occurences["deletePushRule:::kind"]=1
operation_parameters_minimum_occurences["deletePushRule:::ruleId"]=1
operation_parameters_minimum_occurences["getNotifications:::from"]=0
operation_parameters_minimum_occurences["getNotifications:::limit"]=0
operation_parameters_minimum_occurences["getNotifications:::only"]=0
operation_parameters_minimum_occurences["getPushRule:::scope"]=1
operation_parameters_minimum_occurences["getPushRule:::kind"]=1
operation_parameters_minimum_occurences["getPushRule:::ruleId"]=1
operation_parameters_minimum_occurences["getPushRuleActions:::scope"]=1
operation_parameters_minimum_occurences["getPushRuleActions:::kind"]=1
operation_parameters_minimum_occurences["getPushRuleActions:::ruleId"]=1
operation_parameters_minimum_occurences["isPushRuleEnabled:::scope"]=1
operation_parameters_minimum_occurences["isPushRuleEnabled:::kind"]=1
operation_parameters_minimum_occurences["isPushRuleEnabled:::ruleId"]=1
operation_parameters_minimum_occurences["modifyPushRule:::scope"]=1
operation_parameters_minimum_occurences["modifyPushRule:::kind"]=1
operation_parameters_minimum_occurences["modifyPushRule:::ruleId"]=1
operation_parameters_minimum_occurences["modifyPushRule:::PushRuleRequest"]=1
operation_parameters_minimum_occurences["modifyPushRule:::before"]=0
operation_parameters_minimum_occurences["modifyPushRule:::after"]=0
operation_parameters_minimum_occurences["setPushRuleActions:::scope"]=1
operation_parameters_minimum_occurences["setPushRuleActions:::kind"]=1
operation_parameters_minimum_occurences["setPushRuleActions:::ruleId"]=1
operation_parameters_minimum_occurences["setPushRuleActions:::body"]=1
operation_parameters_minimum_occurences["setPushRuleStatus:::scope"]=1
operation_parameters_minimum_occurences["setPushRuleStatus:::kind"]=1
operation_parameters_minimum_occurences["setPushRuleStatus:::ruleId"]=1
operation_parameters_minimum_occurences["setPushRuleStatus:::body"]=1
operation_parameters_minimum_occurences["setPushers:::PushersRequest"]=1
operation_parameters_minimum_occurences["createRoom:::body"]=0
operation_parameters_minimum_occurences["createRoomAlias:::roomAlias"]=1
operation_parameters_minimum_occurences["createRoomAlias:::roomInfo"]=1
operation_parameters_minimum_occurences["deleteRoomAlias:::roomAlias"]=1
operation_parameters_minimum_occurences["getRoomId:::roomAlias"]=1
operation_parameters_minimum_occurences["filterPublicRooms:::body"]=1
operation_parameters_minimum_occurences["filterPublicRooms:::server"]=0
operation_parameters_minimum_occurences["listPublicRooms:::limit"]=0
operation_parameters_minimum_occurences["listPublicRooms:::since"]=0
operation_parameters_minimum_occurences["listPublicRooms:::server"]=0
operation_parameters_minimum_occurences["roomBanUser:::roomId"]=1
operation_parameters_minimum_occurences["roomBanUser:::body"]=1
operation_parameters_minimum_occurences["roomForget:::roomId"]=1
operation_parameters_minimum_occurences["roomInvite:::roomId"]=1
operation_parameters_minimum_occurences["roomInvite:::body"]=1
operation_parameters_minimum_occurences["roomInviteUser:::roomId"]=1
operation_parameters_minimum_occurences["roomInviteUser:::body"]=1
operation_parameters_minimum_occurences["roomJoin:::roomId"]=1
operation_parameters_minimum_occurences["roomJoin:::ThirdParty"]=0
operation_parameters_minimum_occurences["roomJoinByAlias:::roomIdOrAlias"]=1
operation_parameters_minimum_occurences["roomJoinByAlias:::ThirdPartySigned"]=0
operation_parameters_minimum_occurences["roomKickUser:::roomId"]=1
operation_parameters_minimum_occurences["roomKickUser:::body"]=1
operation_parameters_minimum_occurences["roomLeave:::roomId"]=1
operation_parameters_minimum_occurences["roomUnbanUser:::roomId"]=1
operation_parameters_minimum_occurences["roomUnbanUser:::body"]=1
operation_parameters_minimum_occurences["createFilter:::userId"]=1
operation_parameters_minimum_occurences["createFilter:::filter"]=1
operation_parameters_minimum_occurences["getAllRoomStates:::roomId"]=1
operation_parameters_minimum_occurences["getEvent:::eventId"]=1
operation_parameters_minimum_occurences["getEventWithContext:::roomId"]=1
operation_parameters_minimum_occurences["getEventWithContext:::eventId"]=1
operation_parameters_minimum_occurences["getEventWithContext:::limit"]=0
operation_parameters_minimum_occurences["getFilter:::userId"]=1
operation_parameters_minimum_occurences["getFilter:::filterId"]=1
operation_parameters_minimum_occurences["getRoomMembers:::roomId"]=1
operation_parameters_minimum_occurences["getRoomState:::roomId"]=1
operation_parameters_minimum_occurences["getRoomState:::eventType"]=1
operation_parameters_minimum_occurences["getRoomStateWithKey:::roomId"]=1
operation_parameters_minimum_occurences["getRoomStateWithKey:::eventType"]=1
operation_parameters_minimum_occurences["getRoomStateWithKey:::stateKey"]=1
operation_parameters_minimum_occurences["initialSync:::limit"]=0
operation_parameters_minimum_occurences["initialSync:::archived"]=0
operation_parameters_minimum_occurences["listEvents:::roomId"]=1
operation_parameters_minimum_occurences["listEvents:::from"]=1
operation_parameters_minimum_occurences["listEvents:::dir"]=1
operation_parameters_minimum_occurences["listEvents:::to"]=0
operation_parameters_minimum_occurences["listEvents:::limit"]=0
operation_parameters_minimum_occurences["listEvents:::filter"]=0
operation_parameters_minimum_occurences["listenForEvents:::from"]=0
operation_parameters_minimum_occurences["listenForEvents:::timeout"]=0
operation_parameters_minimum_occurences["listenForEvents:::room_id"]=0
operation_parameters_minimum_occurences["roomInitialSync:::roomId"]=1
operation_parameters_minimum_occurences["sendEvent:::roomId"]=1
operation_parameters_minimum_occurences["sendEvent:::eventType"]=1
operation_parameters_minimum_occurences["sendEvent:::txnId"]=1
operation_parameters_minimum_occurences["sendEvent:::body"]=0
operation_parameters_minimum_occurences["sendReceipt:::roomId"]=1
operation_parameters_minimum_occurences["sendReceipt:::receiptType"]=1
operation_parameters_minimum_occurences["sendReceipt:::eventId"]=1
operation_parameters_minimum_occurences["sendReceipt:::receipt"]=0
operation_parameters_minimum_occurences["setRoomState:::roomId"]=1
operation_parameters_minimum_occurences["setRoomState:::eventType"]=1
operation_parameters_minimum_occurences["setRoomState:::body"]=0
operation_parameters_minimum_occurences["setRoomStateWithKey:::roomId"]=1
operation_parameters_minimum_occurences["setRoomStateWithKey:::eventType"]=1
operation_parameters_minimum_occurences["setRoomStateWithKey:::stateKey"]=1
operation_parameters_minimum_occurences["setRoomStateWithKey:::body"]=0
operation_parameters_minimum_occurences["setTypingState:::userId"]=1
operation_parameters_minimum_occurences["setTypingState:::roomId"]=1
operation_parameters_minimum_occurences["setTypingState:::typingState"]=1
operation_parameters_minimum_occurences["stripEvent:::roomId"]=1
operation_parameters_minimum_occurences["stripEvent:::eventId"]=1
operation_parameters_minimum_occurences["stripEvent:::txnId"]=1
operation_parameters_minimum_occurences["stripEvent:::body"]=0
operation_parameters_minimum_occurences["sync:::filter"]=0
operation_parameters_minimum_occurences["sync:::since"]=0
operation_parameters_minimum_occurences["sync:::full_state"]=0
operation_parameters_minimum_occurences["sync:::set_presence"]=0
operation_parameters_minimum_occurences["sync:::timeout"]=0
operation_parameters_minimum_occurences["search:::next_batch"]=0
operation_parameters_minimum_occurences["search:::body"]=0
operation_parameters_minimum_occurences["sendToDevice:::eventType"]=1
operation_parameters_minimum_occurences["sendToDevice:::txnId"]=1
operation_parameters_minimum_occurences["sendToDevice:::body"]=1
operation_parameters_minimum_occurences["whoIs:::userId"]=1
operation_parameters_minimum_occurences["login:::body"]=0
operation_parameters_minimum_occurences["addCredentials:::body"]=0
operation_parameters_minimum_occurences["addUserTag:::userId"]=1
operation_parameters_minimum_occurences["addUserTag:::roomId"]=1
operation_parameters_minimum_occurences["addUserTag:::tag"]=1
operation_parameters_minimum_occurences["addUserTag:::body"]=1
operation_parameters_minimum_occurences["changePassword:::body"]=0
operation_parameters_minimum_occurences["deactivateAccount:::body"]=0
operation_parameters_minimum_occurences["deleteUserTag:::userId"]=1
operation_parameters_minimum_occurences["deleteUserTag:::roomId"]=1
operation_parameters_minimum_occurences["deleteUserTag:::tag"]=1
operation_parameters_minimum_occurences["getAvatar:::userId"]=1
operation_parameters_minimum_occurences["getDisplayName:::userId"]=1
operation_parameters_minimum_occurences["getUserProfile:::userId"]=1
operation_parameters_minimum_occurences["getUserTags:::userId"]=1
operation_parameters_minimum_occurences["getUserTags:::roomId"]=1
operation_parameters_minimum_occurences["registerAccount:::kind"]=0
operation_parameters_minimum_occurences["registerAccount:::body"]=0
operation_parameters_minimum_occurences["requestEmailValidation:::body"]=0
operation_parameters_minimum_occurences["setAccountData:::userId"]=1
operation_parameters_minimum_occurences["setAccountData:::type"]=1
operation_parameters_minimum_occurences["setAccountData:::content"]=1
operation_parameters_minimum_occurences["setAccountDataForRoom:::userId"]=1
operation_parameters_minimum_occurences["setAccountDataForRoom:::roomId"]=1
operation_parameters_minimum_occurences["setAccountDataForRoom:::type"]=1
operation_parameters_minimum_occurences["setAccountDataForRoom:::content"]=1
operation_parameters_minimum_occurences["setAvatar:::userId"]=1
operation_parameters_minimum_occurences["setAvatar:::avatar_url"]=1
operation_parameters_minimum_occurences["setDisplayName:::userId"]=1
operation_parameters_minimum_occurences["setDisplayName:::displayName"]=1

##
# This array stores the maximum number of allowed occurences for parameter
# 1 - single value
# 2 - 2 values
# N - N values
# 0 - unlimited
declare -A operation_parameters_maximum_occurences
operation_parameters_maximum_occurences["casRedirect:::redirectUrl"]=0
operation_parameters_maximum_occurences["casTicket:::redirectUrl"]=0
operation_parameters_maximum_occurences["casTicket:::ticket"]=0
operation_parameters_maximum_occurences["deleteDevice:::deviceId"]=0
operation_parameters_maximum_occurences["deleteDevice:::body"]=0
operation_parameters_maximum_occurences["getDevice:::deviceId"]=0
operation_parameters_maximum_occurences["updateDevice:::deviceId"]=0
operation_parameters_maximum_occurences["updateDevice:::body"]=0
operation_parameters_maximum_occurences["claimKeys:::query"]=0
operation_parameters_maximum_occurences["downloadKeys:::query"]=0
operation_parameters_maximum_occurences["getChangedKeys:::from"]=0
operation_parameters_maximum_occurences["getChangedKeys:::to"]=0
operation_parameters_maximum_occurences["uploadKeys:::keys"]=0
operation_parameters_maximum_occurences["downloadMedia:::serverName"]=0
operation_parameters_maximum_occurences["downloadMedia:::mediaId"]=0
operation_parameters_maximum_occurences["downloadMediaFile:::serverName"]=0
operation_parameters_maximum_occurences["downloadMediaFile:::mediaId"]=0
operation_parameters_maximum_occurences["downloadMediaFile:::fileName"]=0
operation_parameters_maximum_occurences["downloadMediaThumbnail:::serverName"]=0
operation_parameters_maximum_occurences["downloadMediaThumbnail:::mediaId"]=0
operation_parameters_maximum_occurences["downloadMediaThumbnail:::width"]=0
operation_parameters_maximum_occurences["downloadMediaThumbnail:::height"]=0
operation_parameters_maximum_occurences["downloadMediaThumbnail:::method"]=0
operation_parameters_maximum_occurences["uploadMedia:::content"]=0
operation_parameters_maximum_occurences["uploadMedia:::Content-Type"]=0
operation_parameters_maximum_occurences["uploadMedia:::filename"]=0
operation_parameters_maximum_occurences["getPresenceList:::userId"]=0
operation_parameters_maximum_occurences["getPresenceStatus:::userId"]=0
operation_parameters_maximum_occurences["setPresenceList:::userId"]=0
operation_parameters_maximum_occurences["setPresenceList:::presence_diff"]=0
operation_parameters_maximum_occurences["setPresenceStatus:::userId"]=0
operation_parameters_maximum_occurences["setPresenceStatus:::presenceState"]=0
operation_parameters_maximum_occurences["deletePushRule:::scope"]=0
operation_parameters_maximum_occurences["deletePushRule:::kind"]=0
operation_parameters_maximum_occurences["deletePushRule:::ruleId"]=0
operation_parameters_maximum_occurences["getNotifications:::from"]=0
operation_parameters_maximum_occurences["getNotifications:::limit"]=0
operation_parameters_maximum_occurences["getNotifications:::only"]=0
operation_parameters_maximum_occurences["getPushRule:::scope"]=0
operation_parameters_maximum_occurences["getPushRule:::kind"]=0
operation_parameters_maximum_occurences["getPushRule:::ruleId"]=0
operation_parameters_maximum_occurences["getPushRuleActions:::scope"]=0
operation_parameters_maximum_occurences["getPushRuleActions:::kind"]=0
operation_parameters_maximum_occurences["getPushRuleActions:::ruleId"]=0
operation_parameters_maximum_occurences["isPushRuleEnabled:::scope"]=0
operation_parameters_maximum_occurences["isPushRuleEnabled:::kind"]=0
operation_parameters_maximum_occurences["isPushRuleEnabled:::ruleId"]=0
operation_parameters_maximum_occurences["modifyPushRule:::scope"]=0
operation_parameters_maximum_occurences["modifyPushRule:::kind"]=0
operation_parameters_maximum_occurences["modifyPushRule:::ruleId"]=0
operation_parameters_maximum_occurences["modifyPushRule:::PushRuleRequest"]=0
operation_parameters_maximum_occurences["modifyPushRule:::before"]=0
operation_parameters_maximum_occurences["modifyPushRule:::after"]=0
operation_parameters_maximum_occurences["setPushRuleActions:::scope"]=0
operation_parameters_maximum_occurences["setPushRuleActions:::kind"]=0
operation_parameters_maximum_occurences["setPushRuleActions:::ruleId"]=0
operation_parameters_maximum_occurences["setPushRuleActions:::body"]=0
operation_parameters_maximum_occurences["setPushRuleStatus:::scope"]=0
operation_parameters_maximum_occurences["setPushRuleStatus:::kind"]=0
operation_parameters_maximum_occurences["setPushRuleStatus:::ruleId"]=0
operation_parameters_maximum_occurences["setPushRuleStatus:::body"]=0
operation_parameters_maximum_occurences["setPushers:::PushersRequest"]=0
operation_parameters_maximum_occurences["createRoom:::body"]=0
operation_parameters_maximum_occurences["createRoomAlias:::roomAlias"]=0
operation_parameters_maximum_occurences["createRoomAlias:::roomInfo"]=0
operation_parameters_maximum_occurences["deleteRoomAlias:::roomAlias"]=0
operation_parameters_maximum_occurences["getRoomId:::roomAlias"]=0
operation_parameters_maximum_occurences["filterPublicRooms:::body"]=0
operation_parameters_maximum_occurences["filterPublicRooms:::server"]=0
operation_parameters_maximum_occurences["listPublicRooms:::limit"]=0
operation_parameters_maximum_occurences["listPublicRooms:::since"]=0
operation_parameters_maximum_occurences["listPublicRooms:::server"]=0
operation_parameters_maximum_occurences["roomBanUser:::roomId"]=0
operation_parameters_maximum_occurences["roomBanUser:::body"]=0
operation_parameters_maximum_occurences["roomForget:::roomId"]=0
operation_parameters_maximum_occurences["roomInvite:::roomId"]=0
operation_parameters_maximum_occurences["roomInvite:::body"]=0
operation_parameters_maximum_occurences["roomInviteUser:::roomId"]=0
operation_parameters_maximum_occurences["roomInviteUser:::body"]=0
operation_parameters_maximum_occurences["roomJoin:::roomId"]=0
operation_parameters_maximum_occurences["roomJoin:::ThirdParty"]=0
operation_parameters_maximum_occurences["roomJoinByAlias:::roomIdOrAlias"]=0
operation_parameters_maximum_occurences["roomJoinByAlias:::ThirdPartySigned"]=0
operation_parameters_maximum_occurences["roomKickUser:::roomId"]=0
operation_parameters_maximum_occurences["roomKickUser:::body"]=0
operation_parameters_maximum_occurences["roomLeave:::roomId"]=0
operation_parameters_maximum_occurences["roomUnbanUser:::roomId"]=0
operation_parameters_maximum_occurences["roomUnbanUser:::body"]=0
operation_parameters_maximum_occurences["createFilter:::userId"]=0
operation_parameters_maximum_occurences["createFilter:::filter"]=0
operation_parameters_maximum_occurences["getAllRoomStates:::roomId"]=0
operation_parameters_maximum_occurences["getEvent:::eventId"]=0
operation_parameters_maximum_occurences["getEventWithContext:::roomId"]=0
operation_parameters_maximum_occurences["getEventWithContext:::eventId"]=0
operation_parameters_maximum_occurences["getEventWithContext:::limit"]=0
operation_parameters_maximum_occurences["getFilter:::userId"]=0
operation_parameters_maximum_occurences["getFilter:::filterId"]=0
operation_parameters_maximum_occurences["getRoomMembers:::roomId"]=0
operation_parameters_maximum_occurences["getRoomState:::roomId"]=0
operation_parameters_maximum_occurences["getRoomState:::eventType"]=0
operation_parameters_maximum_occurences["getRoomStateWithKey:::roomId"]=0
operation_parameters_maximum_occurences["getRoomStateWithKey:::eventType"]=0
operation_parameters_maximum_occurences["getRoomStateWithKey:::stateKey"]=0
operation_parameters_maximum_occurences["initialSync:::limit"]=0
operation_parameters_maximum_occurences["initialSync:::archived"]=0
operation_parameters_maximum_occurences["listEvents:::roomId"]=0
operation_parameters_maximum_occurences["listEvents:::from"]=0
operation_parameters_maximum_occurences["listEvents:::dir"]=0
operation_parameters_maximum_occurences["listEvents:::to"]=0
operation_parameters_maximum_occurences["listEvents:::limit"]=0
operation_parameters_maximum_occurences["listEvents:::filter"]=0
operation_parameters_maximum_occurences["listenForEvents:::from"]=0
operation_parameters_maximum_occurences["listenForEvents:::timeout"]=0
operation_parameters_maximum_occurences["listenForEvents:::room_id"]=0
operation_parameters_maximum_occurences["roomInitialSync:::roomId"]=0
operation_parameters_maximum_occurences["sendEvent:::roomId"]=0
operation_parameters_maximum_occurences["sendEvent:::eventType"]=0
operation_parameters_maximum_occurences["sendEvent:::txnId"]=0
operation_parameters_maximum_occurences["sendEvent:::body"]=0
operation_parameters_maximum_occurences["sendReceipt:::roomId"]=0
operation_parameters_maximum_occurences["sendReceipt:::receiptType"]=0
operation_parameters_maximum_occurences["sendReceipt:::eventId"]=0
operation_parameters_maximum_occurences["sendReceipt:::receipt"]=0
operation_parameters_maximum_occurences["setRoomState:::roomId"]=0
operation_parameters_maximum_occurences["setRoomState:::eventType"]=0
operation_parameters_maximum_occurences["setRoomState:::body"]=0
operation_parameters_maximum_occurences["setRoomStateWithKey:::roomId"]=0
operation_parameters_maximum_occurences["setRoomStateWithKey:::eventType"]=0
operation_parameters_maximum_occurences["setRoomStateWithKey:::stateKey"]=0
operation_parameters_maximum_occurences["setRoomStateWithKey:::body"]=0
operation_parameters_maximum_occurences["setTypingState:::userId"]=0
operation_parameters_maximum_occurences["setTypingState:::roomId"]=0
operation_parameters_maximum_occurences["setTypingState:::typingState"]=0
operation_parameters_maximum_occurences["stripEvent:::roomId"]=0
operation_parameters_maximum_occurences["stripEvent:::eventId"]=0
operation_parameters_maximum_occurences["stripEvent:::txnId"]=0
operation_parameters_maximum_occurences["stripEvent:::body"]=0
operation_parameters_maximum_occurences["sync:::filter"]=0
operation_parameters_maximum_occurences["sync:::since"]=0
operation_parameters_maximum_occurences["sync:::full_state"]=0
operation_parameters_maximum_occurences["sync:::set_presence"]=0
operation_parameters_maximum_occurences["sync:::timeout"]=0
operation_parameters_maximum_occurences["search:::next_batch"]=0
operation_parameters_maximum_occurences["search:::body"]=0
operation_parameters_maximum_occurences["sendToDevice:::eventType"]=0
operation_parameters_maximum_occurences["sendToDevice:::txnId"]=0
operation_parameters_maximum_occurences["sendToDevice:::body"]=0
operation_parameters_maximum_occurences["whoIs:::userId"]=0
operation_parameters_maximum_occurences["login:::body"]=0
operation_parameters_maximum_occurences["addCredentials:::body"]=0
operation_parameters_maximum_occurences["addUserTag:::userId"]=0
operation_parameters_maximum_occurences["addUserTag:::roomId"]=0
operation_parameters_maximum_occurences["addUserTag:::tag"]=0
operation_parameters_maximum_occurences["addUserTag:::body"]=0
operation_parameters_maximum_occurences["changePassword:::body"]=0
operation_parameters_maximum_occurences["deactivateAccount:::body"]=0
operation_parameters_maximum_occurences["deleteUserTag:::userId"]=0
operation_parameters_maximum_occurences["deleteUserTag:::roomId"]=0
operation_parameters_maximum_occurences["deleteUserTag:::tag"]=0
operation_parameters_maximum_occurences["getAvatar:::userId"]=0
operation_parameters_maximum_occurences["getDisplayName:::userId"]=0
operation_parameters_maximum_occurences["getUserProfile:::userId"]=0
operation_parameters_maximum_occurences["getUserTags:::userId"]=0
operation_parameters_maximum_occurences["getUserTags:::roomId"]=0
operation_parameters_maximum_occurences["registerAccount:::kind"]=0
operation_parameters_maximum_occurences["registerAccount:::body"]=0
operation_parameters_maximum_occurences["requestEmailValidation:::body"]=0
operation_parameters_maximum_occurences["setAccountData:::userId"]=0
operation_parameters_maximum_occurences["setAccountData:::type"]=0
operation_parameters_maximum_occurences["setAccountData:::content"]=0
operation_parameters_maximum_occurences["setAccountDataForRoom:::userId"]=0
operation_parameters_maximum_occurences["setAccountDataForRoom:::roomId"]=0
operation_parameters_maximum_occurences["setAccountDataForRoom:::type"]=0
operation_parameters_maximum_occurences["setAccountDataForRoom:::content"]=0
operation_parameters_maximum_occurences["setAvatar:::userId"]=0
operation_parameters_maximum_occurences["setAvatar:::avatar_url"]=0
operation_parameters_maximum_occurences["setDisplayName:::userId"]=0
operation_parameters_maximum_occurences["setDisplayName:::displayName"]=0

##
# The type of collection for specifying multiple values for parameter:
# - multi, csv, ssv, tsv
declare -A operation_parameters_collection_type
operation_parameters_collection_type["casRedirect:::redirectUrl"]=""
operation_parameters_collection_type["casTicket:::redirectUrl"]=""
operation_parameters_collection_type["casTicket:::ticket"]=""
operation_parameters_collection_type["deleteDevice:::deviceId"]=""
operation_parameters_collection_type["deleteDevice:::body"]=""
operation_parameters_collection_type["getDevice:::deviceId"]=""
operation_parameters_collection_type["updateDevice:::deviceId"]=""
operation_parameters_collection_type["updateDevice:::body"]=""
operation_parameters_collection_type["claimKeys:::query"]=""
operation_parameters_collection_type["downloadKeys:::query"]=""
operation_parameters_collection_type["getChangedKeys:::from"]=""
operation_parameters_collection_type["getChangedKeys:::to"]=""
operation_parameters_collection_type["uploadKeys:::keys"]=""
operation_parameters_collection_type["downloadMedia:::serverName"]=""
operation_parameters_collection_type["downloadMedia:::mediaId"]=""
operation_parameters_collection_type["downloadMediaFile:::serverName"]=""
operation_parameters_collection_type["downloadMediaFile:::mediaId"]=""
operation_parameters_collection_type["downloadMediaFile:::fileName"]=""
operation_parameters_collection_type["downloadMediaThumbnail:::serverName"]=""
operation_parameters_collection_type["downloadMediaThumbnail:::mediaId"]=""
operation_parameters_collection_type["downloadMediaThumbnail:::width"]=""
operation_parameters_collection_type["downloadMediaThumbnail:::height"]=""
operation_parameters_collection_type["downloadMediaThumbnail:::method"]=""
operation_parameters_collection_type["uploadMedia:::content"]=""
operation_parameters_collection_type["uploadMedia:::Content-Type"]=""
operation_parameters_collection_type["uploadMedia:::filename"]=""
operation_parameters_collection_type["getPresenceList:::userId"]=""
operation_parameters_collection_type["getPresenceStatus:::userId"]=""
operation_parameters_collection_type["setPresenceList:::userId"]=""
operation_parameters_collection_type["setPresenceList:::presence_diff"]=""
operation_parameters_collection_type["setPresenceStatus:::userId"]=""
operation_parameters_collection_type["setPresenceStatus:::presenceState"]=""
operation_parameters_collection_type["deletePushRule:::scope"]=""
operation_parameters_collection_type["deletePushRule:::kind"]=""
operation_parameters_collection_type["deletePushRule:::ruleId"]=""
operation_parameters_collection_type["getNotifications:::from"]=""
operation_parameters_collection_type["getNotifications:::limit"]=""
operation_parameters_collection_type["getNotifications:::only"]=""
operation_parameters_collection_type["getPushRule:::scope"]=""
operation_parameters_collection_type["getPushRule:::kind"]=""
operation_parameters_collection_type["getPushRule:::ruleId"]=""
operation_parameters_collection_type["getPushRuleActions:::scope"]=""
operation_parameters_collection_type["getPushRuleActions:::kind"]=""
operation_parameters_collection_type["getPushRuleActions:::ruleId"]=""
operation_parameters_collection_type["isPushRuleEnabled:::scope"]=""
operation_parameters_collection_type["isPushRuleEnabled:::kind"]=""
operation_parameters_collection_type["isPushRuleEnabled:::ruleId"]=""
operation_parameters_collection_type["modifyPushRule:::scope"]=""
operation_parameters_collection_type["modifyPushRule:::kind"]=""
operation_parameters_collection_type["modifyPushRule:::ruleId"]=""
operation_parameters_collection_type["modifyPushRule:::PushRuleRequest"]=""
operation_parameters_collection_type["modifyPushRule:::before"]=""
operation_parameters_collection_type["modifyPushRule:::after"]=""
operation_parameters_collection_type["setPushRuleActions:::scope"]=""
operation_parameters_collection_type["setPushRuleActions:::kind"]=""
operation_parameters_collection_type["setPushRuleActions:::ruleId"]=""
operation_parameters_collection_type["setPushRuleActions:::body"]=""
operation_parameters_collection_type["setPushRuleStatus:::scope"]=""
operation_parameters_collection_type["setPushRuleStatus:::kind"]=""
operation_parameters_collection_type["setPushRuleStatus:::ruleId"]=""
operation_parameters_collection_type["setPushRuleStatus:::body"]=""
operation_parameters_collection_type["setPushers:::PushersRequest"]=""
operation_parameters_collection_type["createRoom:::body"]=""
operation_parameters_collection_type["createRoomAlias:::roomAlias"]=""
operation_parameters_collection_type["createRoomAlias:::roomInfo"]=""
operation_parameters_collection_type["deleteRoomAlias:::roomAlias"]=""
operation_parameters_collection_type["getRoomId:::roomAlias"]=""
operation_parameters_collection_type["filterPublicRooms:::body"]=""
operation_parameters_collection_type["filterPublicRooms:::server"]=""
operation_parameters_collection_type["listPublicRooms:::limit"]=""
operation_parameters_collection_type["listPublicRooms:::since"]=""
operation_parameters_collection_type["listPublicRooms:::server"]=""
operation_parameters_collection_type["roomBanUser:::roomId"]=""
operation_parameters_collection_type["roomBanUser:::body"]=""
operation_parameters_collection_type["roomForget:::roomId"]=""
operation_parameters_collection_type["roomInvite:::roomId"]=""
operation_parameters_collection_type["roomInvite:::body"]=""
operation_parameters_collection_type["roomInviteUser:::roomId"]=""
operation_parameters_collection_type["roomInviteUser:::body"]=""
operation_parameters_collection_type["roomJoin:::roomId"]=""
operation_parameters_collection_type["roomJoin:::ThirdParty"]=""
operation_parameters_collection_type["roomJoinByAlias:::roomIdOrAlias"]=""
operation_parameters_collection_type["roomJoinByAlias:::ThirdPartySigned"]=""
operation_parameters_collection_type["roomKickUser:::roomId"]=""
operation_parameters_collection_type["roomKickUser:::body"]=""
operation_parameters_collection_type["roomLeave:::roomId"]=""
operation_parameters_collection_type["roomUnbanUser:::roomId"]=""
operation_parameters_collection_type["roomUnbanUser:::body"]=""
operation_parameters_collection_type["createFilter:::userId"]=""
operation_parameters_collection_type["createFilter:::filter"]=""
operation_parameters_collection_type["getAllRoomStates:::roomId"]=""
operation_parameters_collection_type["getEvent:::eventId"]=""
operation_parameters_collection_type["getEventWithContext:::roomId"]=""
operation_parameters_collection_type["getEventWithContext:::eventId"]=""
operation_parameters_collection_type["getEventWithContext:::limit"]=""
operation_parameters_collection_type["getFilter:::userId"]=""
operation_parameters_collection_type["getFilter:::filterId"]=""
operation_parameters_collection_type["getRoomMembers:::roomId"]=""
operation_parameters_collection_type["getRoomState:::roomId"]=""
operation_parameters_collection_type["getRoomState:::eventType"]=""
operation_parameters_collection_type["getRoomStateWithKey:::roomId"]=""
operation_parameters_collection_type["getRoomStateWithKey:::eventType"]=""
operation_parameters_collection_type["getRoomStateWithKey:::stateKey"]=""
operation_parameters_collection_type["initialSync:::limit"]=""
operation_parameters_collection_type["initialSync:::archived"]=""
operation_parameters_collection_type["listEvents:::roomId"]=""
operation_parameters_collection_type["listEvents:::from"]=""
operation_parameters_collection_type["listEvents:::dir"]=""
operation_parameters_collection_type["listEvents:::to"]=""
operation_parameters_collection_type["listEvents:::limit"]=""
operation_parameters_collection_type["listEvents:::filter"]=""
operation_parameters_collection_type["listenForEvents:::from"]=""
operation_parameters_collection_type["listenForEvents:::timeout"]=""
operation_parameters_collection_type["listenForEvents:::room_id"]=""
operation_parameters_collection_type["roomInitialSync:::roomId"]=""
operation_parameters_collection_type["sendEvent:::roomId"]=""
operation_parameters_collection_type["sendEvent:::eventType"]=""
operation_parameters_collection_type["sendEvent:::txnId"]=""
operation_parameters_collection_type["sendEvent:::body"]=""
operation_parameters_collection_type["sendReceipt:::roomId"]=""
operation_parameters_collection_type["sendReceipt:::receiptType"]=""
operation_parameters_collection_type["sendReceipt:::eventId"]=""
operation_parameters_collection_type["sendReceipt:::receipt"]=""
operation_parameters_collection_type["setRoomState:::roomId"]=""
operation_parameters_collection_type["setRoomState:::eventType"]=""
operation_parameters_collection_type["setRoomState:::body"]=""
operation_parameters_collection_type["setRoomStateWithKey:::roomId"]=""
operation_parameters_collection_type["setRoomStateWithKey:::eventType"]=""
operation_parameters_collection_type["setRoomStateWithKey:::stateKey"]=""
operation_parameters_collection_type["setRoomStateWithKey:::body"]=""
operation_parameters_collection_type["setTypingState:::userId"]=""
operation_parameters_collection_type["setTypingState:::roomId"]=""
operation_parameters_collection_type["setTypingState:::typingState"]=""
operation_parameters_collection_type["stripEvent:::roomId"]=""
operation_parameters_collection_type["stripEvent:::eventId"]=""
operation_parameters_collection_type["stripEvent:::txnId"]=""
operation_parameters_collection_type["stripEvent:::body"]=""
operation_parameters_collection_type["sync:::filter"]=""
operation_parameters_collection_type["sync:::since"]=""
operation_parameters_collection_type["sync:::full_state"]=""
operation_parameters_collection_type["sync:::set_presence"]=""
operation_parameters_collection_type["sync:::timeout"]=""
operation_parameters_collection_type["search:::next_batch"]=""
operation_parameters_collection_type["search:::body"]=""
operation_parameters_collection_type["sendToDevice:::eventType"]=""
operation_parameters_collection_type["sendToDevice:::txnId"]=""
operation_parameters_collection_type["sendToDevice:::body"]=""
operation_parameters_collection_type["whoIs:::userId"]=""
operation_parameters_collection_type["login:::body"]=""
operation_parameters_collection_type["addCredentials:::body"]=""
operation_parameters_collection_type["addUserTag:::userId"]=""
operation_parameters_collection_type["addUserTag:::roomId"]=""
operation_parameters_collection_type["addUserTag:::tag"]=""
operation_parameters_collection_type["addUserTag:::body"]=""
operation_parameters_collection_type["changePassword:::body"]=""
operation_parameters_collection_type["deactivateAccount:::body"]=""
operation_parameters_collection_type["deleteUserTag:::userId"]=""
operation_parameters_collection_type["deleteUserTag:::roomId"]=""
operation_parameters_collection_type["deleteUserTag:::tag"]=""
operation_parameters_collection_type["getAvatar:::userId"]=""
operation_parameters_collection_type["getDisplayName:::userId"]=""
operation_parameters_collection_type["getUserProfile:::userId"]=""
operation_parameters_collection_type["getUserTags:::userId"]=""
operation_parameters_collection_type["getUserTags:::roomId"]=""
operation_parameters_collection_type["registerAccount:::kind"]=""
operation_parameters_collection_type["registerAccount:::body"]=""
operation_parameters_collection_type["requestEmailValidation:::body"]=""
operation_parameters_collection_type["setAccountData:::userId"]=""
operation_parameters_collection_type["setAccountData:::type"]=""
operation_parameters_collection_type["setAccountData:::content"]=""
operation_parameters_collection_type["setAccountDataForRoom:::userId"]=""
operation_parameters_collection_type["setAccountDataForRoom:::roomId"]=""
operation_parameters_collection_type["setAccountDataForRoom:::type"]=""
operation_parameters_collection_type["setAccountDataForRoom:::content"]=""
operation_parameters_collection_type["setAvatar:::userId"]=""
operation_parameters_collection_type["setAvatar:::avatar_url"]=""
operation_parameters_collection_type["setDisplayName:::userId"]=""
operation_parameters_collection_type["setDisplayName:::displayName"]=""


##
# Map for body parameters passed after operation as
# PARAMETER==STRING_VALUE or PARAMETER:=NUMERIC_VALUE
# These will be mapped to top level json keys ( { "PARAMETER": "VALUE" })
declare -A body_parameters

##
# These arguments will be directly passed to cURL
curl_arguments=""

##
# The host for making the request
host="$MATRIX_HOST"

##
# The user credentials for basic authentication
basic_auth_credential="$MATRIX_BASIC_AUTH"

##
# The user API key
apikey_auth_credential="$MATRIX_API_KEY"

##
# If true, the script will only output the actual cURL command that would be
# used
print_curl=false

##
# The operation ID passed on the command line
operation=""

##
# The provided Accept header value
header_accept=""

##
# The provided Content-type header value
header_content_type=""

##
# If there is any body content on the stdin pass it to the body of the request
body_content_temp_file=""

##
# If this variable is set to true, the request will be performed even
# if parameters for required query, header or body values are not provided
# (path parameters are still required).
force=false

##
# Declare some mime types abbreviations for easier content-type and accepts
# headers specification
declare -A mime_type_abbreviations
# text/*
mime_type_abbreviations["text"]="text/plain"
mime_type_abbreviations["html"]="text/html"
mime_type_abbreviations["md"]="text/x-markdown"
mime_type_abbreviations["csv"]="text/csv"
mime_type_abbreviations["css"]="text/css"
mime_type_abbreviations["rtf"]="text/rtf"
# application/*
mime_type_abbreviations["json"]="application/json"
mime_type_abbreviations["xml"]="application/xml"
mime_type_abbreviations["yaml"]="application/yaml"
mime_type_abbreviations["js"]="application/javascript"
mime_type_abbreviations["bin"]="application/octet-stream"
mime_type_abbreviations["rdf"]="application/rdf+xml"
# image/*
mime_type_abbreviations["jpg"]="image/jpeg"
mime_type_abbreviations["png"]="image/png"
mime_type_abbreviations["gif"]="image/gif"
mime_type_abbreviations["bmp"]="image/bmp"
mime_type_abbreviations["tiff"]="image/tiff"


##############################################################################
#
# Escape special URL characters
# Based on table at http://www.w3schools.com/tags/ref_urlencode.asp
#
##############################################################################
url_escape() {
    local raw_url="$1"

    value=$(sed -e 's/ /%20/g' \
       -e 's/!/%21/g' \
       -e 's/"/%22/g' \
       -e 's/#/%23/g' \
       -e 's/\&/%26/g' \
       -e 's/'\''/%28/g' \
       -e 's/(/%28/g' \
       -e 's/)/%29/g' \
       -e 's/:/%3A/g' \
       -e 's/\t/%09/g' \
       -e 's/?/%3F/g' <<<$raw_url);

    echo $value
}

##############################################################################
#
# Lookup the mime type abbreviation in the mime_type_abbreviations array.
# If not present assume the user provided a valid mime type
#
##############################################################################
lookup_mime_type() {
    local mime_type=$1

    if [[ ${mime_type_abbreviations[$mime_type]} ]]; then
        echo ${mime_type_abbreviations[$mime_type]}
    else
        echo $1
    fi
}

##############################################################################
#
# Converts an associative array into a list of cURL header
# arguments (-H "KEY: VALUE")
#
##############################################################################
header_arguments_to_curl() {
    local headers_curl=""
    local api_key_header=""
    local api_key_header_in_cli=""

    for key in "${!header_arguments[@]}"; do
        headers_curl+="-H \"${key}: ${header_arguments[${key}]}\" "
        if [[ "${key}XX" == "${api_key_header}XX" ]]; then
            api_key_header_in_cli="YES"
        fi
    done
    headers_curl+=" "

    echo "${headers_curl}"
}

##############################################################################
#
# Converts an associative array into a simple JSON with keys as top
# level object attributes
#
# \todo Add convertion of more complex attributes using paths
#
##############################################################################
body_parameters_to_json() {
    local body_json="-d '{"
    local body_parameter_count=${#body_parameters[@]}
    local count=0
    for key in "${!body_parameters[@]}"; do
        if [[ $((count++)) -gt 0 ]]; then
            body_json+=", "
        fi
        body_json+="\"${key}\": ${body_parameters[${key}]}"
    done
    body_json+="}'"

    if [[ "${#body_parameters[@]}" -eq 0 ]]; then
        echo ""
    else
        echo "${body_json}"
    fi
}

##############################################################################
#
# Helper method for showing error because for example echo in
# build_request_path() is evaluated as part of command line not printed on
# output. Anyway better idea for resource clean up ;-).
#
##############################################################################
ERROR_MSG=""
function finish {
    if [[ -n "$ERROR_MSG" ]]; then
        echo >&2 "${OFF}${RED}$ERROR_MSG"
        echo >&2 "${OFF}Check usage: '${script_name} --help'"
    fi
}
trap finish EXIT


##############################################################################
#
# Validate and build request path including query parameters
#
##############################################################################
build_request_path() {
    local path_template=$1
    local -n path_params=$2
    local -n query_params=$3


    #
    # Check input paramaters count against minimum and maximum required
    #
    if [[ "$force" = false ]]; then
        local was_error=""
        for qparam in "${query_params[@]}" "${path_params[@]}"; do
            local parameter_values=($(sed -e 's/'":::"'/\n/g' <<<"${operation_parameters[$qparam]}"))

            #
            # Check if the number of provided values is not less than minimum required
            #
            if [[ ${#parameter_values[@]} -lt ${operation_parameters_minimum_occurences["${operation}:::${qparam}"]} ]]; then
                echo "ERROR: Too few values provided for '${qparam}' parameter."
                was_error=true
            fi

            #
            # Check if the number of provided values is not more than maximum
            #
            if [[ ${operation_parameters_maximum_occurences["${operation}:::${qparam}"]} -gt 0 \
                  && ${#parameter_values[@]} -gt ${operation_parameters_maximum_occurences["${operation}:::${qparam}"]} ]]; then
                echo "ERROR: Too many values provided for '${qparam}' parameter"
                was_error=true
            fi
        done
        if [[ -n "$was_error" ]]; then
            exit 1
        fi
    fi

    # First replace all path parameters in the path
    for pparam in "${path_params[@]}"; do
        if [[ $path_template =~ (.*)(\{$pparam\})(.*) ]]; then
            path_template=${BASH_REMATCH[1]}${operation_parameters[$pparam]}${BASH_REMATCH[3]}
        fi
    done

    local query_request_part=""

    local query_parameter_count=${#query_params[@]}
    local count=0
    for qparam in "${query_params[@]}"; do
        # Get the array of parameter values
        local parameter_values=($(sed -e 's/'":::"'/\n/g' <<<"${operation_parameters[$qparam]}"))
        local parameter_value=""

        if [[ -n "${parameter_values[@]}" ]]; then
            if [[ $((count++)) -gt 0 ]]; then
                query_request_part+="&"
            fi
        fi

        #
        # Append parameters without specific cardinality
        #
        local collection_type="${operation_parameters_collection_type["${operation}:::${qparam}"]}"
        if [[ ${qparam} == "access_token" ]]; then
            if [[ -n "${parameter_values[@]}" ]]; then
                parameter_value+="${qparam}=${parameter_values}"
            elif [[ -n "$MATRIX_API_KEY" ]]; then
                parameter_value+="${qparam}=$MATRIX_API_KEY"
            else
                echo "Missing ApiKey!!! Define env variable MATRIX_API_KEY like 'export MATRIX_API_KEY=...' or provide on command line option 'access_token=...'"
                exit 1
            fi
        elif [[ "${collection_type}" == "" ]]; then
            local vcount=0
            for qvalue in "${parameter_values[@]}"; do
                if [[ $((vcount++)) -gt 0 ]]; then
                    parameter_value+="&"
                fi
                parameter_value+="${qparam}=${qvalue}"
            done
        #
        # Append parameters specified as 'mutli' collections i.e. param=value1&param=value2&...
        #
        elif [[ "${collection_type}" == "multi" ]]; then
            local vcount=0
            for qvalue in "${parameter_values[@]}"; do
                if [[ $((vcount++)) -gt 0 ]]; then
                    parameter_value+="&"
                fi
                parameter_value+="${qparam}=${qvalue}"
            done
        #
        # Append parameters specified as 'csv' collections i.e. param=value1,value2,...
        #
        elif [[ "${collection_type}" == "csv" ]]; then
            parameter_value+="${qparam}="
            local vcount=0
            for qvalue in "${parameter_values[@]}"; do
                if [[ $((vcount++)) -gt 0 ]]; then
                    parameter_value+=","
                fi
                parameter_value+="${qvalue}"
            done
        #
        # Append parameters specified as 'ssv' collections i.e. param="value1 value2 ..."
        #
        elif [[ "${collection_type}" == "ssv" ]]; then
            parameter_value+="${qparam}="
            local vcount=0
            for qvalue in "${parameter_values[@]}"; do
                if [[ $((vcount++)) -gt 0 ]]; then
                    parameter_value+=" "
                fi
                parameter_value+="${qvalue}"
            done
        #
        # Append parameters specified as 'tsv' collections i.e. param="value1\tvalue2\t..."
        #
        elif [[ "${collection_type}" == "tsv" ]]; then
            parameter_value+="${qparam}="
            local vcount=0
            for qvalue in "${parameter_values[@]}"; do
                if [[ $((vcount++)) -gt 0 ]]; then
                    parameter_value+="\t"
                fi
                parameter_value+="${qvalue}"
            done
        else
            echo "Unsupported collection format \"${collection_type}\""
            exit 1
        fi

        if [[ -n "${parameter_value}" ]]; then
            query_request_part+="${parameter_value}"
        fi

    done


    # Now append query parameters - if any
    if [[ -n "${query_request_part}" ]]; then
        path_template+="?${query_request_part}"
    fi

    echo $path_template
}



###############################################################################
#
# Print main help message
#
###############################################################################
print_help() {
cat <<EOF

${BOLD}${WHITE}Matrix Client-Server Client Config API command line client (API version 1.0.0)${OFF}

${BOLD}${WHITE}Usage${OFF}

  ${GREEN}${script_name}${OFF} [-h|--help] [-V|--version] [--about] [${RED}<curl-options>${OFF}]
           [-ac|--accept ${GREEN}<mime-type>${OFF}] [-ct,--content-type ${GREEN}<mime-type>${OFF}]
           [--host ${CYAN}<url>${OFF}] [--dry-run] [-nc|--no-colors] ${YELLOW}<operation>${OFF} [-h|--help]
           [${BLUE}<headers>${OFF}] [${MAGENTA}<parameters>${OFF}] [${MAGENTA}<body-parameters>${OFF}]

  - ${CYAN}<url>${OFF} - endpoint of the REST service without basepath
           Can also be specified in MATRIX_HOST environment variable.
  - ${RED}<curl-options>${OFF} - any valid cURL options can be passed before ${YELLOW}<operation>${OFF}
  - ${GREEN}<mime-type>${OFF} - either full mime-type or one of supported abbreviations:
                   (text, html, md, csv, css, rtf, json, xml, yaml, js, bin,
                    rdf, jpg, png, gif, bmp, tiff)
  - ${BLUE}<headers>${OFF} - HTTP headers can be passed in the form ${YELLOW}HEADER${OFF}:${BLUE}VALUE${OFF}
  - ${MAGENTA}<parameters>${OFF} - REST operation parameters can be passed in the following
                   forms:
                   * ${YELLOW}KEY${OFF}=${BLUE}VALUE${OFF} - path or query parameters
  - ${MAGENTA}<body-parameters>${OFF} - simple JSON body content (first level only) can be build
                        using the following arguments:
                        * ${YELLOW}KEY${OFF}==${BLUE}VALUE${OFF} - body parameters which will be added to body
                                      JSON as '{ ..., "${YELLOW}KEY${OFF}": "${BLUE}VALUE${OFF}", ... }'
                        * ${YELLOW}KEY${OFF}:=${BLUE}VALUE${OFF} - body parameters which will be added to body
                                      JSON as '{ ..., "${YELLOW}KEY${OFF}": ${BLUE}VALUE${OFF}, ... }'

EOF
    echo -e "${BOLD}${WHITE}Authentication methods${OFF}"
    echo -e ""
    echo -e "  - ${BLUE}Api-key${OFF} - add '${RED}access_token=<api-key>${OFF}' after ${YELLOW}<operation>${OFF}"
    echo -e "              or export ${RED}MATRIX_API_KEY='<api-key>'${OFF}"
    echo ""
    echo -e "${BOLD}${WHITE}Operations (grouped by tags)${OFF}"
    echo ""
    echo -e "${BOLD}${WHITE}[cASAuthentication]${OFF}"
read -d '' ops <<EOF
  ${CYAN}casRedirect${OFF};Redirect the user's browser to the CAS interface.
  ${CYAN}casTicket${OFF};Receive and validate a CAS login ticket.
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[deviceManagement]${OFF}"
read -d '' ops <<EOF
  ${CYAN}deleteDevice${OFF};Delete a device (AUTH)
  ${CYAN}getDevice${OFF};Get a single device (AUTH)
  ${CYAN}getDevices${OFF};List registered devices for the current user (AUTH)
  ${CYAN}updateDevice${OFF};Update a device (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[endtoendEncryption]${OFF}"
read -d '' ops <<EOF
  ${CYAN}claimKeys${OFF};Claim one-time encryption keys. (AUTH)
  ${CYAN}downloadKeys${OFF};Download device identity keys. (AUTH)
  ${CYAN}getChangedKeys${OFF};Query users with recent device key updates. (AUTH)
  ${CYAN}uploadKeys${OFF};Upload end-to-end encryption keys. (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[media]${OFF}"
read -d '' ops <<EOF
  ${CYAN}downloadMedia${OFF};Download content from the content repository.
  ${CYAN}downloadMediaFile${OFF};Download content from the content repository as a given filename.
  ${CYAN}downloadMediaThumbnail${OFF};Download a thumbnail of the content from the content repository.
  ${CYAN}uploadMedia${OFF};Upload some content to the content repository.
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[presence]${OFF}"
read -d '' ops <<EOF
  ${CYAN}getPresenceList${OFF};Get presence events for this presence list.
  ${CYAN}getPresenceStatus${OFF};Get this user's presence state.
  ${CYAN}setPresenceList${OFF};Add or remove users from this presence list. (AUTH)
  ${CYAN}setPresenceStatus${OFF};Update this user's presence state. (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[pushNotifications]${OFF}"
read -d '' ops <<EOF
  ${CYAN}deletePushRule${OFF};Delete a push rule. (AUTH)
  ${CYAN}getNotifications${OFF};Gets a list of events that the user has been notified about (AUTH)
  ${CYAN}getPushRule${OFF};Retrieve a push rule. (AUTH)
  ${CYAN}getPushRuleActions${OFF};The actions for a push rule (AUTH)
  ${CYAN}getPushRules${OFF};Retrieve all push rulesets. (AUTH)
  ${CYAN}getPushers${OFF};Gets the current pushers for the authenticated user (AUTH)
  ${CYAN}isPushRuleEnabled${OFF};Get whether a push rule is enabled (AUTH)
  ${CYAN}modifyPushRule${OFF};Add or change a push rule. (AUTH)
  ${CYAN}setPushRuleActions${OFF};Set the actions for a push rule. (AUTH)
  ${CYAN}setPushRuleStatus${OFF};Enable or disable a push rule. (AUTH)
  ${CYAN}setPushers${OFF};Modify a pusher for this user on the homeserver. (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[roomCreation]${OFF}"
read -d '' ops <<EOF
  ${CYAN}createRoom${OFF};Create a new room (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[roomDirectory]${OFF}"
read -d '' ops <<EOF
  ${CYAN}createRoomAlias${OFF};Create a new mapping from room alias to room ID. (AUTH)
  ${CYAN}deleteRoomAlias${OFF};Remove a mapping of room alias to room ID. (AUTH)
  ${CYAN}getRoomId${OFF};Get the room ID corresponding to this room alias.
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[roomDiscovery]${OFF}"
read -d '' ops <<EOF
  ${CYAN}filterPublicRooms${OFF};Lists the public rooms on the server with optional filter. (AUTH)
  ${CYAN}listPublicRooms${OFF};Lists the public rooms on the server.
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[roomMembership]${OFF}"
read -d '' ops <<EOF
  ${CYAN}roomBanUser${OFF};Ban a user in the room. (AUTH)
  ${CYAN}roomForget${OFF};Stop the requesting user remembering about a particular room. (AUTH)
  ${CYAN}roomInvite${OFF};Invite a user to participate in a particular room. (AUTH)
  ${CYAN}roomInviteUser${OFF};Invite a user to participate in a particular room. (AUTH)
  ${CYAN}roomJoin${OFF};Start the requesting user participating in a particular room. (AUTH)
  ${CYAN}roomJoinByAlias${OFF};Start the requesting user participating in a particular room. (AUTH)
  ${CYAN}roomKickUser${OFF};Kick a user from the room. (AUTH)
  ${CYAN}roomLeave${OFF};Stop the requesting user participating in a particular room. (AUTH)
  ${CYAN}roomUnbanUser${OFF};Unban a user from the room. (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[roomParticipation]${OFF}"
read -d '' ops <<EOF
  ${CYAN}createFilter${OFF};Upload a new filter. (AUTH)
  ${CYAN}getAllRoomStates${OFF};Get all state events in the current state of a room. (AUTH)
  ${CYAN}getEvent${OFF};Get a single event by event ID. (AUTH)
  ${CYAN}getEventWithContext${OFF};Get events and state around the specified event. (AUTH)
  ${CYAN}getFilter${OFF};Download a filter
  ${CYAN}getRoomMembers${OFF};Get the m.room.member events for the room.
  ${CYAN}getRoomState${OFF};Get the state identified by the type, with the empty state key. (AUTH)
  ${CYAN}getRoomStateWithKey${OFF};Get the state identified by the type and key. (AUTH)
  ${CYAN}initialSync${OFF};Get the user's current state. (AUTH)
  ${CYAN}listEvents${OFF};Get a list of events for this room (AUTH)
  ${CYAN}listenForEvents${OFF};Listen on the event stream. (AUTH)
  ${CYAN}roomInitialSync${OFF};Snapshot the current state of a room and its most recent messages. (AUTH)
  ${CYAN}sendEvent${OFF};Send a message event to the given room. (AUTH)
  ${CYAN}sendReceipt${OFF};Send a receipt for the given event ID. (AUTH)
  ${CYAN}setRoomState${OFF};Send a state event to the given room. (AUTH)
  ${CYAN}setRoomStateWithKey${OFF};Send a state event to the given room. (AUTH)
  ${CYAN}setTypingState${OFF};Informs the server that the user has started or stopped typing. (AUTH)
  ${CYAN}stripEvent${OFF};Strips all non-integrity-critical information out of an event. (AUTH)
  ${CYAN}sync${OFF};Synchronise the client's state and receive new messages. (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[search]${OFF}"
read -d '' ops <<EOF
  ${CYAN}search${OFF};Perform a server-side search. (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[sendtoDeviceMessaging]${OFF}"
read -d '' ops <<EOF
  ${CYAN}sendToDevice${OFF};Send an event to a given set of devices. (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[serverAdministration]${OFF}"
read -d '' ops <<EOF
  ${CYAN}versions${OFF};Gets the versions of the specification supported by the server.
  ${CYAN}whoIs${OFF};Gets information about a particular user. (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[sessionManagement]${OFF}"
read -d '' ops <<EOF
  ${CYAN}login${OFF};Authenticates the user.
  ${CYAN}logout${OFF};Invalidates a user access token (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[userData]${OFF}"
read -d '' ops <<EOF
  ${CYAN}addCredentials${OFF};Adds contact information to the user's account. (AUTH)
  ${CYAN}addUserTag${OFF};Add a tag to a room. (AUTH)
  ${CYAN}changePassword${OFF};Changes a user's password. (AUTH)
  ${CYAN}deactivateAccount${OFF};Deactivate a user's account. (AUTH)
  ${CYAN}deleteUserTag${OFF};Remove a tag from the room. (AUTH)
  ${CYAN}getAvatar${OFF};Get the user's avatar URL.
  ${CYAN}getDisplayName${OFF};Get the user's display name.
  ${CYAN}getUserIdentifiers${OFF};Gets a list of a user's third party identifiers. (AUTH)
  ${CYAN}getUserProfile${OFF};Get this user's profile information.
  ${CYAN}getUserTags${OFF};List the tags for a room. (AUTH)
  ${CYAN}registerAccount${OFF};Register for an account on this homeserver.
  ${CYAN}requestEmailValidation${OFF};Requests a validation token be sent to the given email address for the purpose of registering an account
  ${CYAN}requestEmailValidationAfterAdd${OFF};Requests a validation token be sent to the given email address for the purpose of adding an email address to an account
  ${CYAN}requestPasswordReset${OFF};Requests a validation token be sent to the given email address for the purpose of resetting a user's password
  ${CYAN}setAccountData${OFF};Set some account_data for the user. (AUTH)
  ${CYAN}setAccountDataForRoom${OFF};Set some account_data for the user. (AUTH)
  ${CYAN}setAvatar${OFF};Set the user's avatar URL. (AUTH)
  ${CYAN}setDisplayName${OFF};Set the user's display name. (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}[vOIP]${OFF}"
read -d '' ops <<EOF
  ${CYAN}getTurnCredentials${OFF};Obtain TURN server credentials. (AUTH)
EOF
echo "  $ops" | column -t -s ';'
    echo ""
    echo -e "${BOLD}${WHITE}Options${OFF}"
    echo -e "  -h,--help\t\t\t\tPrint this help"
    echo -e "  -V,--version\t\t\t\tPrint API version"
    echo -e "  --about\t\t\t\tPrint the information about service"
    echo -e "  --host ${CYAN}<url>${OFF}\t\t\t\tSpecify the host URL "
echo -e "              \t\t\t\t(e.g. 'https://localhost:8008')"

    echo -e "  --force\t\t\t\tForce command invocation in spite of missing"
    echo -e "         \t\t\t\trequired parameters or wrong content type"
    echo -e "  --dry-run\t\t\t\tPrint out the cURL command without"
    echo -e "           \t\t\t\texecuting it"
    echo -e "  -nc,--no-colors\t\t\tEnforce print without colors, otherwise autodected"
    echo -e "  -ac,--accept ${YELLOW}<mime-type>${OFF}\t\tSet the 'Accept' header in the request"
    echo -e "  -ct,--content-type ${YELLOW}<mime-type>${OFF}\tSet the 'Content-type' header in "
    echo -e "                                \tthe request"
    echo ""
}


##############################################################################
#
# Print REST service description
#
##############################################################################
print_about() {
    echo ""
    echo -e "${BOLD}${WHITE}Matrix Client-Server Client Config API command line client (API version 1.0.0)${OFF}"
    echo ""
    echo -e "License: "
    echo -e "Contact: "
    echo ""
read -d '' appdescription <<EOF

No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
EOF
echo "$appdescription" | paste -sd' ' | fold -sw 80
}


##############################################################################
#
# Print REST api version
#
##############################################################################
print_version() {
    echo ""
    echo -e "${BOLD}Matrix Client-Server Client Config API command line client (API version 1.0.0)${OFF}"
    echo ""
}

##############################################################################
#
# Print help for casRedirect operation
#
##############################################################################
print_casRedirect_help() {
    echo ""
    echo -e "${BOLD}${WHITE}casRedirect - Redirect the user's browser to the CAS interface.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "A web-based Matrix client should instruct the user's browser to
navigate to this endpoint in order to log in via CAS.

The server MUST respond with an HTTP redirect to the CAS interface. The
URI MUST include a ''service'' parameter giving the path of the
|/login/cas/ticket|_ endpoint (including the ''redirectUrl'' query
parameter).

For example, if the endpoint is called with
''redirectUrl=https://client.example.com/?q=p'', it might redirect to
''https://cas.example.com/?service=https%3A%2F%2Fserver.example.com%2F_matrix%2Fclient%2F%CLIENT_MAJOR_VERSION%%2Flogin%2Fcas%2Fticket%3FredirectUrl%3Dhttps%253A%252F%252Fclient.example.com%252F%253Fq%253Dp''." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}redirectUrl${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - URI to which the user will be redirected after the homeserver has
authenticated the user with CAS.${YELLOW} Specify as: redirectUrl=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=302
    echo -e "${result_color_table[${code:0:1}]}  302;A redirect to the CAS interface.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
        echo -e "       ${BOLD}${WHITE}Response headers${OFF}"
        echo -e "       ${BLUE}Location${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/        /'
}
##############################################################################
#
# Print help for casTicket operation
#
##############################################################################
print_casTicket_help() {
    echo ""
    echo -e "${BOLD}${WHITE}casTicket - Receive and validate a CAS login ticket.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Once the CAS server has authenticated the user, it will redirect the
browser to this endpoint (assuming |/login/cas/redirect|_ gave it the
correct ''service'' parameter).

The server MUST call ''/proxyValidate'' on the CAS server, to validate
the ticket supplied by the browser.

If validation is successful, the server must generate a Matrix login
token. It must then respond with an HTTP redirect to the URI given in
the ''redirectUrl'' parameter, adding a ''loginToken'' query parameter
giving the generated token.

If validation is unsuccessful, the server should respond with a ''401
Unauthorized'' error, the body of which will be displayed to the user." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}redirectUrl${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The ''redirectUrl'' originally provided by the client to
|/login/cas/redirect|_.${YELLOW} Specify as: redirectUrl=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}ticket${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - CAS authentication ticket.${YELLOW} Specify as: ticket=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=302
    echo -e "${result_color_table[${code:0:1}]}  302;A redirect to the Matrix client.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
        echo -e "       ${BOLD}${WHITE}Response headers${OFF}"
        echo -e "       ${BLUE}Location${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/        /'
    code=401
    echo -e "${result_color_table[${code:0:1}]}  401;The server was unable to validate the CAS ticket.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for deleteDevice operation
#
##############################################################################
print_deleteDevice_help() {
    echo ""
    echo -e "${BOLD}${WHITE}deleteDevice - Delete a device${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API endpoint uses the 'User-Interactive Authentication API'_.

Deletes the given device, and invalidates any access token assoicated with it." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}deviceId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The device to delete. ${YELLOW}Specify as: deviceId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The device was successfully removed, or had been removed
previously.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=401
    echo -e "${result_color_table[${code:0:1}]}  401;The homeserver requires additional authentication information.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getDevice operation
#
##############################################################################
print_getDevice_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getDevice - Get a single device${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Gets information on a single device, by device id." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}deviceId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The device to retrieve. ${YELLOW}Specify as: deviceId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;Device information${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;The current user has no device with the given ID.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getDevices operation
#
##############################################################################
print_getDevices_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getDevices - List registered devices for the current user${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Gets information about all devices for the current user." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;Device information${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for updateDevice operation
#
##############################################################################
print_updateDevice_help() {
    echo ""
    echo -e "${BOLD}${WHITE}updateDevice - Update a device${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Updates the metadata on the given device." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}deviceId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The device to update. ${YELLOW}Specify as: deviceId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - New information for the device." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The device was successfully updated.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;The current user has no device with the given ID.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for claimKeys operation
#
##############################################################################
print_claimKeys_help() {
    echo ""
    echo -e "${BOLD}${WHITE}claimKeys - Claim one-time encryption keys.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Claims one-time keys for use in pre-key messages." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - Query defining the keys to be claimed" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The claimed keys${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for downloadKeys operation
#
##############################################################################
print_downloadKeys_help() {
    echo ""
    echo -e "${BOLD}${WHITE}downloadKeys - Download device identity keys.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Returns the current devices and identity keys for the given users." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - Query defining the keys to be downloaded" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The device information${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getChangedKeys operation
#
##############################################################################
print_getChangedKeys_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getChangedKeys - Query users with recent device key updates.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Gets a list of users who have updated their device identity keys since a
previous sync token.

The server should include in the results any users who:

* currently share a room with the calling user (ie, both users have
  membership state ''join'');$(tput dim) and $(tput sgr0)
* added new device identity keys or removed an existing device with
  identity keys, between ''from'' and ''to''." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}from${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The desired start point of the list. Should be the ''next_batch'' field
from a response to an earlier call to |/sync|. Users who have not
uploaded new device identity keys since this point, nor deleted
existing devices with identity keys since then, will be excluded
from the results.${YELLOW} Specify as: from=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}to${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The desired end point of the list. Should be the ''next_batch''
field from a recent call to |/sync| - typically the most recent
such call. This may be used by the server as a hint to check its
caches are up to date.${YELLOW} Specify as: to=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The list of users who updated their devices.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for uploadKeys operation
#
##############################################################################
print_uploadKeys_help() {
    echo ""
    echo -e "${BOLD}${WHITE}uploadKeys - Upload end-to-end encryption keys.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Publishes end-to-end encryption keys for the device." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - The keys to be published" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The provided keys were sucessfully uploaded.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for downloadMedia operation
#
##############################################################################
print_downloadMedia_help() {
    echo ""
    echo -e "${BOLD}${WHITE}downloadMedia - Download content from the content repository.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}serverName${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The server name from the ''mxc://'' URI (the authoritory component) ${YELLOW}Specify as: serverName=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}mediaId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The media ID from the ''mxc://'' URI (the path component) ${YELLOW}Specify as: mediaId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The content that was previously uploaded.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
        echo -e "       ${BOLD}${WHITE}Response headers${OFF}"
        echo -e "       ${BLUE}Content-Type${OFF} - The content type of the file that was previously uploaded." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/        /'
        echo -e "       ${BLUE}Content-Disposition${OFF} - The name of the file that was previously uploaded, if set." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/        /'
}
##############################################################################
#
# Print help for downloadMediaFile operation
#
##############################################################################
print_downloadMediaFile_help() {
    echo ""
    echo -e "${BOLD}${WHITE}downloadMediaFile - Download content from the content repository as a given filename.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}serverName${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The server name from the ''mxc://'' URI (the authoritory component) ${YELLOW}Specify as: serverName=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}mediaId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The media ID from the ''mxc://'' URI (the path component) ${YELLOW}Specify as: mediaId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}fileName${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The filename to give in the Content-Disposition ${YELLOW}Specify as: fileName=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The content that was previously uploaded.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
        echo -e "       ${BOLD}${WHITE}Response headers${OFF}"
        echo -e "       ${BLUE}Content-Type${OFF} - The content type of the file that was previously uploaded." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/        /'
        echo -e "       ${BLUE}Content-Disposition${OFF} - The name of file given in the request" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/        /'
}
##############################################################################
#
# Print help for downloadMediaThumbnail operation
#
##############################################################################
print_downloadMediaThumbnail_help() {
    echo ""
    echo -e "${BOLD}${WHITE}downloadMediaThumbnail - Download a thumbnail of the content from the content repository.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}serverName${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The server name from the ''mxc://'' URI (the authoritory component) ${YELLOW}Specify as: serverName=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}mediaId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The media ID from the ''mxc://'' URI (the path component) ${YELLOW}Specify as: mediaId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}width${OFF} ${BLUE}[Integer]${OFF}${OFF} - The$(tput dim) desired $(tput sgr0)width of the thumbnail. The actual thumbnail may not
match the size specified.${YELLOW} Specify as: width=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}height${OFF} ${BLUE}[Integer]${OFF}${OFF} - The$(tput dim) desired $(tput sgr0)height of the thumbnail. The actual thumbnail may not
match the size specified.${YELLOW} Specify as: height=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}method${OFF} ${BLUE}[String]${OFF}${OFF} - The desired resizing method.${YELLOW} Specify as: method=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;A thumbnail of the requested content.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
        echo -e "       ${BOLD}${WHITE}Response headers${OFF}"
        echo -e "       ${BLUE}Content-Type${OFF} - The content type of the thumbnail." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/        /'
}
##############################################################################
#
# Print help for uploadMedia operation
#
##############################################################################
print_uploadMedia_help() {
    echo ""
    echo -e "${BOLD}${WHITE}uploadMedia - Upload some content to the content repository.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}Content-Type${OFF} ${BLUE}[String]${OFF}${OFF} - The content type of the file being uploaded ${YELLOW}Specify as: Content-Type:value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}filename${OFF} ${BLUE}[String]${OFF}${OFF} - The name of the file being uploaded${YELLOW} Specify as: filename=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The content to be uploaded." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The MXC URI for the uploaded content.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getPresenceList operation
#
##############################################################################
print_getPresenceList_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getPresenceList - Get presence events for this presence list.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Retrieve a list of presence events for every user on this list." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user whose presence list should be retrieved. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;A list of presence events for this list.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getPresenceStatus operation
#
##############################################################################
print_getPresenceStatus_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getPresenceStatus - Get this user's presence state.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Get the given user's presence state." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user whose presence state to get. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The presence state for this user.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;There is no presence state for this user. This user may not exist or
isn't exposing presence information to you.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setPresenceList operation
#
##############################################################################
print_setPresenceList_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setPresenceList - Add or remove users from this presence list.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Adds or removes users from this presence list." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user whose presence list is being modified. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The modifications to make to this presence list." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The list was updated.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setPresenceStatus operation
#
##############################################################################
print_setPresenceStatus_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setPresenceStatus - Update this user's presence state.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API sets the given user's presence state. When setting the status,
the activity time is updated to reflect that activity; the client does
not need to specify the ''last_active_ago'' field. You cannot set the
presence state of another user." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user whose presence state to update. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The updated presence state." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The new presence state was set.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for deletePushRule operation
#
##############################################################################
print_deletePushRule_help() {
    echo ""
    echo -e "${BOLD}${WHITE}deletePushRule - Delete a push rule.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This endpoint removes the push rule defined in the path." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}scope${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - ''global'' to specify global rules. ${YELLOW}Specify as: scope=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}kind${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The kind of rule ${YELLOW}Specify as: kind=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}ruleId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The identifier for the rule. ${YELLOW}Specify as: ruleId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The push rule was deleted.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getNotifications operation
#
##############################################################################
print_getNotifications_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getNotifications - Gets a list of events that the user has been notified about${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API is used to paginate through the list of events that the
user has been, or would have been notified about." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}from${OFF} ${BLUE}[String]${OFF}${OFF} - Pagination token given to retrieve the next set of events.${YELLOW} Specify as: from=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}limit${OFF} ${BLUE}[Integer]${OFF}${OFF} - Limit on the number of events to return in this request.${YELLOW} Specify as: limit=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}only${OFF} ${BLUE}[String]${OFF}${OFF} - Allows basic filtering of events returned. Supply ''highlight''
to return only events where the notification had the highlight
tweak set.${YELLOW} Specify as: only=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;A batch of events is being returned${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getPushRule operation
#
##############################################################################
print_getPushRule_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getPushRule - Retrieve a push rule.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Retrieve a single specified push rule." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}scope${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - ''global'' to specify global rules. ${YELLOW}Specify as: scope=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}kind${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The kind of rule ${YELLOW}Specify as: kind=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}ruleId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The identifier for the rule. ${YELLOW}Specify as: ruleId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The specific push rule. This will also include keys specific to the
rule itself such as the rule's ''actions'' and ''conditions'' if set.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getPushRuleActions operation
#
##############################################################################
print_getPushRuleActions_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getPushRuleActions - The actions for a push rule${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This endpoint get the actions for the specified push rule." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}scope${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - Either ''global'' or ''device/<profile_tag>'' to specify global
rules or device rules for the given ''profile_tag''. ${YELLOW}Specify as: scope=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}kind${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The kind of rule ${YELLOW}Specify as: kind=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}ruleId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The identifier for the rule. ${YELLOW}Specify as: ruleId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The actions for this push rule.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getPushRules operation
#
##############################################################################
print_getPushRules_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getPushRules - Retrieve all push rulesets.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Retrieve all push rulesets for this user. Clients can \"drill-down\" on
the rulesets by suffixing a ''scope'' to this path e.g.
''/pushrules/global/''. This will return a subset of this data under the
specified key e.g. the ''global'' key." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;All the push rulesets for this user.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getPushers operation
#
##############################################################################
print_getPushers_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getPushers - Gets the current pushers for the authenticated user${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Gets all currently active pushers for the authenticated user" | paste -sd' ' | fold -sw 80
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The pushers for this user${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for isPushRuleEnabled operation
#
##############################################################################
print_isPushRuleEnabled_help() {
    echo ""
    echo -e "${BOLD}${WHITE}isPushRuleEnabled - Get whether a push rule is enabled${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This endpoint gets whether the specified push rule is enabled." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}scope${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - Either ''global'' or ''device/<profile_tag>'' to specify global
rules or device rules for the given ''profile_tag''. ${YELLOW}Specify as: scope=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}kind${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The kind of rule ${YELLOW}Specify as: kind=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}ruleId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The identifier for the rule. ${YELLOW}Specify as: ruleId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;Whether the push rule is enabled.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for modifyPushRule operation
#
##############################################################################
print_modifyPushRule_help() {
    echo ""
    echo -e "${BOLD}${WHITE}modifyPushRule - Add or change a push rule.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This endpoint allows the creation, modification and deletion of pushers
for this user ID. The behaviour of this endpoint varies depending on the
values in the JSON body." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}scope${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - ''global'' to specify global rules. ${YELLOW}Specify as: scope=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}kind${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The kind of rule ${YELLOW}Specify as: kind=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}ruleId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The identifier for the rule. ${YELLOW}Specify as: ruleId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}before${OFF} ${BLUE}[String]${OFF}${OFF} - Use 'before' with a ''rule_id'' as its value to make the new rule the
next-most important rule with respect to the given user defined rule.
It is not possible to add a rule relative to a predefined server rule.${YELLOW} Specify as: before=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}after${OFF} ${BLUE}[String]${OFF}${OFF} - This makes the new rule the next-less important rule relative to the
given user defined rule. It is not possible to add a rule relative
to a predefined server rule.${YELLOW} Specify as: after=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The push rule data. Additional top-level keys may be present depending
on the parameters for the rule ''kind''." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The pusher was set.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=400
    echo -e "${result_color_table[${code:0:1}]}  400;There was a problem configuring this push rule.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setPushRuleActions operation
#
##############################################################################
print_setPushRuleActions_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setPushRuleActions - Set the actions for a push rule.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This endpoint allows clients to change the actions of a push rule.
This can be used to change the actions of builtin rules." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}scope${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - ''global'' to specify global rules. ${YELLOW}Specify as: scope=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}kind${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The kind of rule ${YELLOW}Specify as: kind=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}ruleId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The identifier for the rule. ${YELLOW}Specify as: ruleId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The action(s) to perform when the conditions for this rule are met." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The actions for the push rule were set.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setPushRuleStatus operation
#
##############################################################################
print_setPushRuleStatus_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setPushRuleStatus - Enable or disable a push rule.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This endpoint allows clients to enable or disable the specified push rule." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}scope${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - ''global'' to specify global rules. ${YELLOW}Specify as: scope=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}kind${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The kind of rule ${YELLOW}Specify as: kind=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}ruleId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The identifier for the rule. ${YELLOW}Specify as: ruleId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - Whether the push rule is enabled or not." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The push rule was enabled or disabled.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setPushers operation
#
##############################################################################
print_setPushers_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setPushers - Modify a pusher for this user on the homeserver.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This endpoint allows the creation, modification and deletion of 'pushers'_
for this user ID. The behaviour of this endpoint varies depending on the
values in the JSON body." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The pusher information" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The pusher was set.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=400
    echo -e "${result_color_table[${code:0:1}]}  400;One or more of the pusher values were invalid.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for createRoom operation
#
##############################################################################
print_createRoom_help() {
    echo ""
    echo -e "${BOLD}${WHITE}createRoom - Create a new room${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Create a new room with various configuration options.

The server MUST apply the normal state resolution rules when creating
the new room, including checking power levels for each event. It MUST
apply the events implied by the request in the following order:

1. Events set by ''presets''.

2. Events listed in ''initial_state'', in the order that they are
   listed.

3. Events implied by ''name'' and ''topic''.

4. Invite events implied by ''invite'' and ''invite_3pid''." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - The desired room configuration." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;Information about the newly created room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=400
    echo -e "${result_color_table[${code:0:1}]}  400;The request is invalid. A meaningful ''errcode'' and description
error text will be returned. Example reasons for rejection include:

- The request body is malformed (''errcode'' set to ''M_BAD_JSON''
  or ''M_NOT_JSON'').

- The room alias specified is already taken (''errcode'' set to
  ''M_ROOM_IN_USE'').

- The initial state implied by the parameters to the request is
  invalid: for example, the user's ''power_level'' is set below
  that necessary to set the room name (''errcode'' set to
  ''M_INVALID_ROOM_STATE'').${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for createRoomAlias operation
#
##############################################################################
print_createRoomAlias_help() {
    echo ""
    echo -e "${BOLD}${WHITE}createRoomAlias - Create a new mapping from room alias to room ID.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomAlias${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room alias to set. ${YELLOW}Specify as: roomAlias=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - Information about this room alias." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The mapping was created.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=409
    echo -e "${result_color_table[${code:0:1}]}  409;A room alias with that name already exists.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for deleteRoomAlias operation
#
##############################################################################
print_deleteRoomAlias_help() {
    echo ""
    echo -e "${BOLD}${WHITE}deleteRoomAlias - Remove a mapping of room alias to room ID.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Remove a mapping of room alias to room ID.

Servers may choose to implement additional access control checks here, for instance that room aliases can only be deleted by their creator or a server administrator." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomAlias${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room alias to remove. ${YELLOW}Specify as: roomAlias=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The mapping was deleted.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getRoomId operation
#
##############################################################################
print_getRoomId_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getRoomId - Get the room ID corresponding to this room alias.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Requests that the server resolve a room alias to a room ID.

The server will use the federation API to resolve the alias if the
domain part of the alias does not correspond to the server's own
domain." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomAlias${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room alias. ${YELLOW}Specify as: roomAlias=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The room ID and other information for this alias.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;There is no mapped room ID for this room alias.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for filterPublicRooms operation
#
##############################################################################
print_filterPublicRooms_help() {
    echo ""
    echo -e "${BOLD}${WHITE}filterPublicRooms - Lists the public rooms on the server with optional filter.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Lists the public rooms on the server, with optional filter.

This API returns paginated responses. The rooms are ordered by the number
of joined members, with the largest rooms first." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}server${OFF} ${BLUE}[String]${OFF}${OFF} - The server to fetch the public room lists from. Defaults to the
local server.${YELLOW} Specify as: server=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - Options for which rooms to return." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;A list of the rooms on the server.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for listPublicRooms operation
#
##############################################################################
print_listPublicRooms_help() {
    echo ""
    echo -e "${BOLD}${WHITE}listPublicRooms - Lists the public rooms on the server.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Lists the public rooms on the server.

This API returns paginated responses. The rooms are ordered by the number
of joined members, with the largest rooms first." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}limit${OFF} ${BLUE}[Integer]${OFF}${OFF} - Limit the number of results returned.${YELLOW} Specify as: limit=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}since${OFF} ${BLUE}[String]${OFF}${OFF} - A pagination token from a previous request, allowing clients to
get the next (or previous) batch of rooms.
The direction of pagination is specified solely by which token
is supplied, rather than via an explicit flag.${YELLOW} Specify as: since=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}server${OFF} ${BLUE}[String]${OFF}${OFF} - The server to fetch the public room lists from. Defaults to the
local server.${YELLOW} Specify as: server=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;A list of the rooms on the server.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for roomBanUser operation
#
##############################################################################
print_roomBanUser_help() {
    echo ""
    echo -e "${BOLD}${WHITE}roomBanUser - Ban a user in the room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Ban a user in the room. If the user is currently in the room, also kick them.

When a user is banned from a room, they may not join it or be invited to it until they are unbanned.

The caller must have the required power level in order to perform this operation." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room identifier (not alias) from which the user should be banned. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The user has been kicked and banned from the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You do not have permission to ban the user from the room. A meaningful ''errcode'' and description error text will be returned. Example reasons for rejections are:

- The banner is not currently in the room.
- The banner's power level is insufficient to ban users from the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for roomForget operation
#
##############################################################################
print_roomForget_help() {
    echo ""
    echo -e "${BOLD}${WHITE}roomForget - Stop the requesting user remembering about a particular room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API stops a user remembering about a particular room.

In general, history is a first class citizen in Matrix. After this API
is called, however, a user will no longer be able to retrieve history
for this room. If all users on a homeserver forget a room, the room is
eligible for deletion from that homeserver.

If the user is currently joined to the room, they will implicitly leave
the room as part of this API call." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room identifier to forget. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The room has been forgotten.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for roomInvite operation
#
##############################################################################
print_roomInvite_help() {
    echo ""
    echo -e "${BOLD}${WHITE}roomInvite - Invite a user to participate in a particular room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e ".. _invite-by-third-party-id-endpoint:

*Note that there are two forms of this API, which are documented separately.
This version of the API does not require that the inviter know the Matrix
identifier of the invitee, and instead relies on third party identifiers.
The homeserver uses an identity server to perform the mapping from
third party identifier to a Matrix identifier. The other is documented in the*
'joining rooms section'_.

This API invites a user to participate in a particular room.
They do not start participating in the room until they actually join the
room.

Only users currently in a particular room can invite other users to
join that room.

If the identity server did know the Matrix user identifier for the
third party identifier, the homeserver will append a ''m.room.member''
event to the room.

If the identity server does not know a Matrix user identifier for the
passed third party identifier, the homeserver will issue an invitation
which can be accepted upon providing proof of ownership of the third
party identifier. This is achieved by the identity server generating a
token, which it gives to the inviting homeserver. The homeserver will
add an ''m.room.third_party_invite'' event into the graph for the room,
containing that token.

When the invitee binds the invited third party identifier to a Matrix
user ID, the identity server will give the user a list of pending
invitations, each containing:

- The room ID to which they were invited

- The token given to the homeserver

- A signature of the token, signed with the identity server's private key

- The matrix user ID who invited them to the room

If a token is requested from the identity server, the homeserver will
append a ''m.room.third_party_invite'' event to the room.

.. _joining rooms section: 'invite-by-user-id-endpoint'_" | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room identifier (not alias) to which to invite the user. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The user has been invited to join the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You do not have permission to invite the user to the room. A meaningful ''errcode'' and description error text will be returned. Example reasons for rejections are:

- The invitee has been banned from the room.
- The invitee is already a member of the room.
- The inviter is not currently in the room.
- The inviter's power level is insufficient to invite users to the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for roomInviteUser operation
#
##############################################################################
print_roomInviteUser_help() {
    echo ""
    echo -e "${BOLD}${WHITE}roomInviteUser - Invite a user to participate in a particular room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e ".. _invite-by-user-id-endpoint:

*Note that there are two forms of this API, which are documented separately.
This version of the API requires that the inviter knows the Matrix
identifier of the invitee. The other is documented in the*
'third party invites section'_.

This API invites a user to participate in a particular room.
They do not start participating in the room until they actually join the
room.

Only users currently in a particular room can invite other users to
join that room.

If the user was invited to the room, the homeserver will append a
''m.room.member'' event to the room.

.. _third party invites section: 'invite-by-third-party-id-endpoint'_" | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room identifier (not alias) to which to invite the user. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The user has been invited to join the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You do not have permission to invite the user to the room. A meaningful ''errcode'' and description error text will be returned. Example reasons for rejections are:

- The invitee has been banned from the room.
- The invitee is already a member of the room.
- The inviter is not currently in the room.
- The inviter's power level is insufficient to invite users to the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for roomJoin operation
#
##############################################################################
print_roomJoin_help() {
    echo ""
    echo -e "${BOLD}${WHITE}roomJoin - Start the requesting user participating in a particular room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "*Note that this API requires a room ID, not alias.* ''/join/{roomIdOrAlias}'' *exists if you have a room alias.*

This API starts a user participating in a particular room, if that user
is allowed to participate in that room. After this call, the client is
allowed to see all current state events in the room, and all subsequent
events associated with the room until the user leaves the room.

After a user has joined a room, the room will appear as an entry in the
response of the |/initialSync|_ and |/sync|_ APIs.

If a ''third_party_signed'' was supplied, the homeserver must verify
that it matches a pending ''m.room.third_party_invite'' event in the
room, and perform key validity checking if required by the event." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room identifier (not alias) to join. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The room has been joined.

The joined room ID must be returned in the ''room_id'' field.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You do not have permission to join the room. A meaningful ''errcode'' and description error text will be returned. Example reasons for rejection are:

- The room is invite-only and the user was not invited.
- The user has been banned from the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for roomJoinByAlias operation
#
##############################################################################
print_roomJoinByAlias_help() {
    echo ""
    echo -e "${BOLD}${WHITE}roomJoinByAlias - Start the requesting user participating in a particular room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "*Note that this API takes either a room ID or alias, unlike* ''/room/{roomId}/join''.

This API starts a user participating in a particular room, if that user
is allowed to participate in that room. After this call, the client is
allowed to see all current state events in the room, and all subsequent
events associated with the room until the user leaves the room.

After a user has joined a room, the room will appear as an entry in the
response of the |/initialSync|_ and |/sync|_ APIs.

If a ''third_party_signed'' was supplied, the homeserver must verify
that it matches a pending ''m.room.third_party_invite'' event in the
room, and perform key validity checking if required by the event." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomIdOrAlias${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room identifier or alias to join. ${YELLOW}Specify as: roomIdOrAlias=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The room has been joined.

The joined room ID must be returned in the ''room_id'' field.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You do not have permission to join the room. A meaningful ''errcode'' and description error text will be returned. Example reasons for rejection are:

- The room is invite-only and the user was not invited.
- The user has been banned from the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for roomKickUser operation
#
##############################################################################
print_roomKickUser_help() {
    echo ""
    echo -e "${BOLD}${WHITE}roomKickUser - Kick a user from the room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Kick a user from the room.

The caller must have the required power level in order to perform this operation." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room identifier (not alias) from which the user should be kicked. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The user has been kicked from the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You do not have permission to kick the user from the room. A meaningful ''errcode'' and description error text will be returned. Example reasons for rejections are:

- The kicker is not currently in the room.
- The kickee is not currently in the room.
- The kicker's power level is insufficient to kick users from the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for roomLeave operation
#
##############################################################################
print_roomLeave_help() {
    echo ""
    echo -e "${BOLD}${WHITE}roomLeave - Stop the requesting user participating in a particular room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API stops a user participating in a particular room.

If the user was already in the room, they will no longer be able to see
new events in the room. If the room requires an invite to join, they
will need to be re-invited before they can re-join.

If the user was invited to the room, but had not joined, this call
serves to reject the invite.

The user will still be allowed to retrieve history from the room which
they were previously allowed to see." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room identifier to leave. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The room has been left.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for roomUnbanUser operation
#
##############################################################################
print_roomUnbanUser_help() {
    echo ""
    echo -e "${BOLD}${WHITE}roomUnbanUser - Unban a user from the room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Unban a user from the room. This allows them to be invited to the room,
and join if they would otherwise be allowed to join according to its join rules.

The caller must have the required power level in order to perform this operation." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room identifier (not alias) from which the user should be unbanned. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The user has been unbanned from the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You do not have permission to unban the user from the room. A meaningful ''errcode'' and description error text will be returned. Example reasons for rejections are:

- The unbanner's power level is insufficient to unban users from the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for createFilter operation
#
##############################################################################
print_createFilter_help() {
    echo ""
    echo -e "${BOLD}${WHITE}createFilter - Upload a new filter.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Uploads a new filter definition to the homeserver.
Returns a filter ID that may be used in future requests to
restrict which events are returned to the client." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The id of the user uploading the filter. The access token must be authorized to make requests for this user id. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The filter to upload." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The filter was created.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getAllRoomStates operation
#
##############################################################################
print_getAllRoomStates_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getAllRoomStates - Get all state events in the current state of a room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Get the state events for the current state of a room." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room to look up the state for. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The current state of the room${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You aren't a member of the room and weren't previously a member of the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getEvent operation
#
##############################################################################
print_getEvent_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getEvent - Get a single event by event ID.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Get a single event based on ''event_id''. You must have permission to
retrieve this event e.g. by being a member in the room for this event.

This endpoint was deprecated in r0 of this specification. Clients
should instead call the |/rooms/{roomId}/context/{eventId}|_ API." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}eventId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The event ID to get. ${YELLOW}Specify as: eventId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The full event.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;The event was not found or you do not have permission to read this event.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getEventWithContext operation
#
##############################################################################
print_getEventWithContext_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getEventWithContext - Get events and state around the specified event.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API returns a number of events that happened just before and
after the specified event. This allows clients to get the context
surrounding an event." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room to get events from. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}eventId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The event to get context around. ${YELLOW}Specify as: eventId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}limit${OFF} ${BLUE}[Integer]${OFF}${OFF} - The maximum number of events to return. Default: 10.${YELLOW} Specify as: limit=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The events and state surrounding the requested event.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getFilter operation
#
##############################################################################
print_getFilter_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getFilter - Download a filter${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user ID to download a filter for. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}filterId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The filter ID to download. ${YELLOW}Specify as: filterId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;\"The filter defintion\"${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getRoomMembers operation
#
##############################################################################
print_getRoomMembers_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getRoomMembers - Get the m.room.member events for the room.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Get the list of members for this room." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room to get the member events for. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;A list of members of the room. If you are joined to the room then
this will be the current members of the room. If you have left the
room then this will be the members of the room when you left.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You aren't a member of the room and weren't previously a member of the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getRoomState operation
#
##############################################################################
print_getRoomState_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getRoomState - Get the state identified by the type, with the empty state key.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Looks up the contents of a state event in a room. If the user is
joined to the room then the state is taken from the current
state of the room. If the user has left the room then the state is
taken from the state of the room when they left.

This looks up the state event with the empty state key." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room to look up the state in. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}eventType${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The type of state to look up. ${YELLOW}Specify as: eventType=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The content of the state event.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You aren't a member of the room and weren't previously a member of the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;The room has no state with the given type or key.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getRoomStateWithKey operation
#
##############################################################################
print_getRoomStateWithKey_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getRoomStateWithKey - Get the state identified by the type and key.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Looks up the contents of a state event in a room. If the user is
joined to the room then the state is taken from the current
state of the room. If the user has left the room then the state is
taken from the state of the room when they left." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room to look up the state in. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}eventType${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The type of state to look up. ${YELLOW}Specify as: eventType=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}stateKey${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The key of the state to look up. ${YELLOW}Specify as: stateKey=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The content of the state event.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You aren't a member of the room and weren't previously a member of the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;The room has no state with the given type or key.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for initialSync operation
#
##############################################################################
print_initialSync_help() {
    echo ""
    echo -e "${BOLD}${WHITE}initialSync - Get the user's current state.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This returns the full state for this user, with an optional limit on the
number of messages per room to return.

This endpoint was deprecated in r0 of this specification. Clients
should instead call the |/sync|_ API with no ''since'' parameter. See
the 'migration guide
<https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>'_." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}limit${OFF} ${BLUE}[Integer]${OFF}${OFF} - The maximum number of messages to return for each room.${YELLOW} Specify as: limit=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}archived${OFF} ${BLUE}[Boolean]${OFF}${OFF} - Whether to include rooms that the user has left. If ''false'' then
only rooms that the user has been invited to or has joined are
included. If set to ''true'' then rooms that the user has left are
included as well. By default this is ''false''.${YELLOW} Specify as: archived=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The user's current state.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;There is no avatar URL for this user or this user does not exist.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for listEvents operation
#
##############################################################################
print_listEvents_help() {
    echo ""
    echo -e "${BOLD}${WHITE}listEvents - Get a list of events for this room${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API returns a list of message and state events for a room. It uses
pagination query parameters to paginate history in the room." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room to get events from. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}from${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The token to start returning events from. This token can be obtained
from a ''prev_batch'' token returned for each room by the sync API,
or from a ''start'' or ''end'' token returned by a previous request
to this endpoint.${YELLOW} Specify as: from=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}dir${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The direction to return events from.${YELLOW} Specify as: dir=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}to${OFF} ${BLUE}[String]${OFF}${OFF} - The token to stop returning events at. This token can be obtained from
a ''prev_batch'' token returned for each room by the sync endpoint,
or from a ''start'' or ''end'' token returned by a previous request to
this endpoint.${YELLOW} Specify as: to=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}limit${OFF} ${BLUE}[Integer]${OFF}${OFF} - The maximum number of events to return. Default: 10.${YELLOW} Specify as: limit=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}filter${OFF} ${BLUE}[String]${OFF}${OFF} - A JSON RoomEventFilter to filter returned events with.${YELLOW} Specify as: filter=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;A list of messages with a new token to request more.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You aren't a member of the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for listenForEvents operation
#
##############################################################################
print_listenForEvents_help() {
    echo ""
    echo -e "${BOLD}${WHITE}listenForEvents - Listen on the event stream.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This will listen for new events related to a particular room and return
them to the caller. This will block until an event is received, or until
the ''timeout'' is reached.

This API is the same as the normal ''/events'' endpoint, but can be
called by users who have not joined the room.

Note that the normal ''/events'' endpoint has been deprecated. This
API will also be deprecated at some point, but its replacement is not
yet known." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}from${OFF} ${BLUE}[String]${OFF}${OFF} - The token to stream from. This token is either from a previous
request to this API or from the initial sync API.${YELLOW} Specify as: from=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}timeout${OFF} ${BLUE}[Integer]${OFF}${OFF} - The maximum time in milliseconds to wait for an event.${YELLOW} Specify as: timeout=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}room_id${OFF} ${BLUE}[String]${OFF}${OFF} - The room ID for which events should be returned.${YELLOW} Specify as: room_id=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The events received, which may be none.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=400
    echo -e "${result_color_table[${code:0:1}]}  400;Bad pagination ''from'' parameter.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for roomInitialSync operation
#
##############################################################################
print_roomInitialSync_help() {
    echo ""
    echo -e "${BOLD}${WHITE}roomInitialSync - Snapshot the current state of a room and its most recent messages.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Get a copy of the current state and the most recent messages in a room.

This endpoint was deprecated in r0 of this specification. There is no
direct replacement; the relevant information is returned by the
|/sync|_ API. See the 'migration guide
<https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>'_." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room to get the data. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The current state of the room${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;You aren't a member of the room and weren't previously a member of the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for sendEvent operation
#
##############################################################################
print_sendEvent_help() {
    echo ""
    echo -e "${BOLD}${WHITE}sendEvent - Send a message event to the given room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This endpoint is used to send a message event to a room. Message events
allow access to historical events and pagination, making them suited
for \"once-off\" activity in a room.

The body of the request should be the content object of the event; the
fields in this object will vary depending on the type of event. See
'Room Events'_ for the m. event specification." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room to send the event to. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}eventType${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The type of event to send. ${YELLOW}Specify as: eventType=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}txnId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The transaction ID for this event. Clients should generate an
ID unique across requests with the same access token; it will be
used by the server to ensure idempotency of requests. ${YELLOW}Specify as: txnId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;An ID for the sent event.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for sendReceipt operation
#
##############################################################################
print_sendReceipt_help() {
    echo ""
    echo -e "${BOLD}${WHITE}sendReceipt - Send a receipt for the given event ID.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API updates the marker for the given receipt type to the event ID
specified." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room in which to send the event. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}receiptType${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The type of receipt to send. ${YELLOW}Specify as: receiptType=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}eventId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The event ID to acknowledge up to. ${YELLOW}Specify as: eventId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - Extra receipt information to attach to ''content'' if any. The
server will automatically set the ''ts'' field." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The receipt was sent.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setRoomState operation
#
##############################################################################
print_setRoomState_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setRoomState - Send a state event to the given room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "State events can be sent using this endpoint. This endpoint is
equivalent to calling '/rooms/{roomId}/state/{eventType}/{stateKey}'
with an empty 'stateKey'. Previous state events with matching
'<roomId>' and '<eventType>', and empty '<stateKey>', will be overwritten.

Requests to this endpoint$(tput bold) cannot use transaction IDs $(tput sgr0)
like other ''PUT'' paths because they cannot be differentiated from the
''state_key''. Furthermore, ''POST'' is unsupported on state paths.

The body of the request should be the content object of the event; the
fields in this object will vary depending on the type of event. See
'Room Events'_ for the ''m.'' event specification." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room to set the state in ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}eventType${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The type of event to send. ${YELLOW}Specify as: eventType=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;An ID for the sent event.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setRoomStateWithKey operation
#
##############################################################################
print_setRoomStateWithKey_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setRoomStateWithKey - Send a state event to the given room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "State events can be sent using this endpoint.  These events will be
overwritten if ''<room id>'', ''<event type>'' and ''<state key>'' all
match.

Requests to this endpoint$(tput bold) cannot use transaction IDs $(tput sgr0)
like other ''PUT'' paths because they cannot be differentiated from the
''state_key''. Furthermore, ''POST'' is unsupported on state paths.

The body of the request should be the content object of the event; the
fields in this object will vary depending on the type of event. See
'Room Events'_ for the ''m.'' event specification." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room to set the state in ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}eventType${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The type of event to send. ${YELLOW}Specify as: eventType=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}stateKey${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The state_key for the state to send. Defaults to the empty string. ${YELLOW}Specify as: stateKey=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;An ID for the sent event.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setTypingState operation
#
##############################################################################
print_setTypingState_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setTypingState - Informs the server that the user has started or stopped typing.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This tells the server that the user is typing for the next N
milliseconds where N is the value specified in the ''timeout'' key.
Alternatively, if ''typing'' is ''false'', it tells the server that the
user has stopped typing." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user who has started to type. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room in which the user is typing. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The current typing state." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The new typing state was set.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for stripEvent operation
#
##############################################################################
print_stripEvent_help() {
    echo ""
    echo -e "${BOLD}${WHITE}stripEvent - Strips all non-integrity-critical information out of an event.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Strips all information out of an event which isn't critical to the
integrity of the server-side representation of the room.

This cannot be undone.

Users may redact their own events, and any user with a power level
greater than or equal to the 'redact' power level of the room may
redact events there." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The room from which to redact the event. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}eventId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The ID of the event to redact ${YELLOW}Specify as: eventId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}txnId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The transaction ID for this event. Clients should generate a
unique ID; it will be used by the server to ensure idempotency of requests. ${YELLOW}Specify as: txnId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;An ID for the redaction event.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for sync operation
#
##############################################################################
print_sync_help() {
    echo ""
    echo -e "${BOLD}${WHITE}sync - Synchronise the client's state and receive new messages.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Synchronise the client's state with the latest state on the server.
Clients use this API when they first log in to get an initial snapshot
of the state on the server, and then continue to call this API to get
incremental deltas to the state, and to receive new messages." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}filter${OFF} ${BLUE}[String]${OFF}${OFF} - The ID of a filter created using the filter API or a filter JSON
object encoded as a string. The server will detect whether it is
an ID or a JSON object by whether the first character is a ''\"{\"''
open brace. Passing the JSON inline is best suited to one off
requests. Creating a filter using the filter API is recommended for
clients that reuse the same filter multiple times, for example in
long poll requests.${YELLOW} Specify as: filter=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}since${OFF} ${BLUE}[String]${OFF}${OFF} - A point in time to continue a sync from.${YELLOW} Specify as: since=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}full_state${OFF} ${BLUE}[Boolean]${OFF}${OFF} - Controls whether to include the full state for all rooms the user
is a member of.

If this is set to ''true'', then all state events will be returned,
even if ''since'' is non-empty. The timeline will still be limited
by the ''since'' parameter. In this case, the ''timeout'' parameter
will be ignored and the query will return immediately, possibly with
an empty timeline.

If ''false'', and ''since'' is non-empty, only state which has
changed since the point indicated by ''since'' will be returned.

By default, this is ''false''.${YELLOW} Specify as: full_state=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}set_presence${OFF} ${BLUE}[String]${OFF}${OFF} - Controls whether the client is automatically marked as online by
polling this API. If this parameter is omitted then the client is
automatically marked as online when it uses this API. Otherwise if
the parameter is set to \"offline\" then the client is not marked as
being online when it uses this API.${YELLOW} Specify as: set_presence=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}timeout${OFF} ${BLUE}[Integer]${OFF}${OFF} - The maximum time to poll in milliseconds before returning this
request.${YELLOW} Specify as: timeout=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The initial snapshot or delta for the client to use to update their state.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for search operation
#
##############################################################################
print_search_help() {
    echo ""
    echo -e "${BOLD}${WHITE}search - Perform a server-side search.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Performs a full text search across different categories." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}next_batch${OFF} ${BLUE}[String]${OFF}${OFF} - The point to return events from. If given, this should be a
'next_batch' result from a previous call to this endpoint.${YELLOW} Specify as: next_batch=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;Results of the search.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=400
    echo -e "${result_color_table[${code:0:1}]}  400;Part of the request was invalid.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for sendToDevice operation
#
##############################################################################
print_sendToDevice_help() {
    echo ""
    echo -e "${BOLD}${WHITE}sendToDevice - Send an event to a given set of devices.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This endpoint is used to send send-to-device events to a set of
client devices." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}eventType${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The type of event to send. ${YELLOW}Specify as: eventType=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}txnId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The transaction ID for this event. Clients should generate an
ID unique across requests with the same access token; it will be
used by the server to ensure idempotency of requests. ${YELLOW}Specify as: txnId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The message was successfully sent.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for versions operation
#
##############################################################################
print_versions_help() {
    echo ""
    echo -e "${BOLD}${WHITE}versions - Gets the versions of the specification supported by the server.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Gets the versions of the specification supported by the server.

Values will take the form ''rX.Y.Z''.

Only the latest ''Z'' value will be reported for each supported ''X.Y'' value.
i.e. if the server implements ''r0.0.0'', ''r0.0.1'', and ''r1.2.0'', it will report ''r0.0.1'' and ''r1.2.0''." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The versions supported by the server.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for whoIs operation
#
##############################################################################
print_whoIs_help() {
    echo ""
    echo -e "${BOLD}${WHITE}whoIs - Gets information about a particular user.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Gets information about a particular user.

This API may be restricted to only be called by the user being looked
up, or by a server admin. Server-local administrator privileges are not
specified in this document." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user to look up. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The lookup was successful.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for login operation
#
##############################################################################
print_login_help() {
    echo ""
    echo -e "${BOLD}${WHITE}login - Authenticates the user.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Authenticates the user, and issues an access token they can
use to authorize themself in subsequent requests.

If the client does not supply a ''device_id'', the server must
auto-generate one.

The returned access token must be associated with the ''device_id''
supplied by the client or generated by the server. The server may
invalidate any access token previously associated with that device. See
'Relationship between access tokens and devices'_." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The user has been authenticated.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=400
    echo -e "${result_color_table[${code:0:1}]}  400;Part of the request was invalid. For example, the login type may not be recognised.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;The login attempt failed. For example, the password may have been incorrect.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for logout operation
#
##############################################################################
print_logout_help() {
    echo ""
    echo -e "${BOLD}${WHITE}logout - Invalidates a user access token${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Invalidates an existing access token, so that it can no longer be used for
authorization." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The access token used in the request was succesfully invalidated.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for addCredentials operation
#
##############################################################################
print_addCredentials_help() {
    echo ""
    echo -e "${BOLD}${WHITE}addCredentials - Adds contact information to the user's account.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Adds contact information to the user's account." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The addition was successful.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=403
    echo -e "${result_color_table[${code:0:1}]}  403;The credentials could not be verified with the identity server.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for addUserTag operation
#
##############################################################################
print_addUserTag_help() {
    echo ""
    echo -e "${BOLD}${WHITE}addUserTag - Add a tag to a room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Add a tag to the room." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The id of the user to add a tag for. The access token must be
authorized to make requests for this user id. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The id of the room to add a tag to. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}tag${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The tag to add. ${YELLOW}Specify as: tag=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - Extra data for the tag, e.g. ordering." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The tag was successfully added.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for changePassword operation
#
##############################################################################
print_changePassword_help() {
    echo ""
    echo -e "${BOLD}${WHITE}changePassword - Changes a user's password.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Changes the password for an account on this homeserver.

This API endpoint uses the 'User-Interactive Authentication API'_.

An access token should be submitted to this endpoint if the client has
an active session.

The homeserver may change the flows available depending on whether a
valid access token is provided." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The password has been changed.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=401
    echo -e "${result_color_table[${code:0:1}]}  401;The homeserver requires additional authentication information.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for deactivateAccount operation
#
##############################################################################
print_deactivateAccount_help() {
    echo ""
    echo -e "${BOLD}${WHITE}deactivateAccount - Deactivate a user's account.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Deactivate the user's account, removing all ability for the user to
login again.

This API endpoint uses the 'User-Interactive Authentication API'_.

An access token should be submitted to this endpoint if the client has
an active session.

The homeserver may change the flows available depending on whether a
valid access token is provided." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The account has been deactivated.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=401
    echo -e "${result_color_table[${code:0:1}]}  401;The homeserver requires additional authentication information.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for deleteUserTag operation
#
##############################################################################
print_deleteUserTag_help() {
    echo ""
    echo -e "${BOLD}${WHITE}deleteUserTag - Remove a tag from the room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Remove a tag from the room." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The id of the user to remove a tag for. The access token must be
authorized to make requests for this user id. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The id of the room to remove a tag from. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}tag${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The tag to remove. ${YELLOW}Specify as: tag=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The tag was successfully removed${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getAvatar operation
#
##############################################################################
print_getAvatar_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getAvatar - Get the user's avatar URL.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Get the user's avatar URL. This API may be used to fetch the user's
own avatar URL or to query the URL of other users; either locally or
on remote homeservers." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user whose avatar URL to get. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The avatar URL for this user.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;There is no avatar URL for this user or this user does not exist.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getDisplayName operation
#
##############################################################################
print_getDisplayName_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getDisplayName - Get the user's display name.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Get the user's display name. This API may be used to fetch the user's
own displayname or to query the name of other users; either locally or
on remote homeservers." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user whose display name to get. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The display name for this user.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;There is no display name for this user or this user does not exist.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getUserIdentifiers operation
#
##############################################################################
print_getUserIdentifiers_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getUserIdentifiers - Gets a list of a user's third party identifiers.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Gets a list of the third party identifiers that the homeserver has
associated with the user's account.

This is$(tput dim) not $(tput sgr0)the same as the list of third party identifiers bound to
the user's Matrix ID in Identity Servers.

Identifiers in this list may be used by the homeserver as, for example,
identifiers that it will accept to reset the user's account password." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The lookup was successful.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getUserProfile operation
#
##############################################################################
print_getUserProfile_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getUserProfile - Get this user's profile information.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Get the combined profile information for this user. This API may be used
to fetch the user's own profile information or other users; either
locally or on remote homeservers. This API may return keys which are not
limited to ''displayname'' or ''avatar_url''." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user whose profile information to get. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The avatar URL for this user.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=404
    echo -e "${result_color_table[${code:0:1}]}  404;There is no profile information for this user or this user does not exist.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getUserTags operation
#
##############################################################################
print_getUserTags_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getUserTags - List the tags for a room.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "List the tags set by a user on a room." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The id of the user to get tags for. The access token must be
authorized to make requests for this user id. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The id of the room to get tags for. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The list of tags for the user for the room.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for registerAccount operation
#
##############################################################################
print_registerAccount_help() {
    echo ""
    echo -e "${BOLD}${WHITE}registerAccount - Register for an account on this homeserver.${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API endpoint uses the 'User-Interactive Authentication API'_.

Register for an account on this homeserver.

There are two kinds of user account:

- 'user' accounts. These accounts may use the full API described in this specification.

- 'guest' accounts. These accounts may have limited permissions and may not be supported by all servers.

If registration is successful, this endpoint will issue an access token
the client can use to authorize itself in subsequent requests.

If the client does not supply a ''device_id'', the server must
auto-generate one.

The returned access token must be associated with the ''device_id''
supplied by the client or generated by the server. The server may
invalidate any access token previously associated with that device. See
'Relationship between access tokens and devices'_." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}kind${OFF} ${BLUE}[String]${OFF} ${CYAN}(default: user)${OFF} - The kind of account to register. Defaults to 'user'.${YELLOW} Specify as: kind=value${OFF}" \
        | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The account has been registered.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=400
    echo -e "${result_color_table[${code:0:1}]}  400;Part of the request was invalid. This may include one of the following error codes:

* ''M_USER_IN_USE'' : The desired user ID is already taken.
* ''M_INVALID_USERNAME'' : The desired user ID is not a valid user name.
* ''M_EXCLUSIVE'' : The desired user ID is in the exclusive namespace
  claimed by an application service.

These errors may be returned at any stage of the registration process,
including after authentication if the requested user ID was registered
whilst the client was performing authentication.

Homeservers MUST perform the relevant checks and return these codes before
performing User-Interactive Authentication, although they may also return
them after authentication is completed if, for example, the requested user ID
was registered whilst the client was performing authentication.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=401
    echo -e "${result_color_table[${code:0:1}]}  401;The homeserver requires additional authentication information.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for requestEmailValidation operation
#
##############################################################################
print_requestEmailValidation_help() {
    echo ""
    echo -e "${BOLD}${WHITE}requestEmailValidation - Requests a validation token be sent to the given email address for the purpose of registering an account${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Proxies the identity server API ''validate/email/requestToken'', but
first checks that the given email address is not already associated
with an account on this Home Server. Note that, for consistency,
this API takes JSON objects, though the Identity Server API takes
''x-www-form-urlencoded'' parameters. See the Identity Server API for
further information." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF}${OFF} - " | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;An email has been sent to the specified address.
Note that this may be an email containing the validation token or it may be informing
the user of an error.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=400
    echo -e "${result_color_table[${code:0:1}]}  400;Part of the request was invalid. This may include one of the following error codes:

* ''M_THREEPID_IN_USE'' : The email address is already registered to an account on this server.
  However, if the home server has the ability to send email, it is recommended that the server
  instead send an email to the user with instructions on how to reset their password.
  This prevents malicious parties from being able to determine if a given email address
  has an account on the Home Server in question.
* ''M_SERVER_NOT_TRUSTED'' : The ''id_server'' parameter refers to an ID server
  that is not trusted by this Home Server.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for requestEmailValidationAfterAdd operation
#
##############################################################################
print_requestEmailValidationAfterAdd_help() {
    echo ""
    echo -e "${BOLD}${WHITE}requestEmailValidationAfterAdd - Requests a validation token be sent to the given email address for the purpose of adding an email address to an account${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Proxies the identity server API ''validate/email/requestToken'', but
first checks that the given email address is$(tput bold) not $(tput sgr0)already associated
with an account on this Home Server. This API should be used to request
validation tokens when adding an email address to an account. This API's
parameters and response is identical to that of the HS API
|/register/email/requestToken|_ endpoint." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;An email was sent to the given address${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for requestPasswordReset operation
#
##############################################################################
print_requestPasswordReset_help() {
    echo ""
    echo -e "${BOLD}${WHITE}requestPasswordReset - Requests a validation token be sent to the given email address for the purpose of resetting a user's password${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Proxies the identity server API ''validate/email/requestToken'', but
first checks that the given email address$(tput bold) is $(tput sgr0)associated with an account
on this Home Server. This API should be used to request
validation tokens when authenticating for the
'account/password' endpoint. This API's parameters and response are
identical to that of the HS API |/register/email/requestToken|_ except that
'M_THREEPID_NOT_FOUND' may be returned if no account matching the
given email address could be found. The server may instead send an
email to the given address prompting the user to create an account.
'M_THREEPID_IN_USE' may not be returned.

.. |/register/email/requestToken| replace:: ''/register/email/requestToken''

.. _/register/email/requestToken: #post-matrix-client-%CLIENT_MAJOR_VERSION%-register-email-requesttoken" | paste -sd' ' | fold -sw 80
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;An email was sent to the given address${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setAccountData operation
#
##############################################################################
print_setAccountData_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setAccountData - Set some account_data for the user.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Set some account_data for the client. This config is only visible to the user
that set the account_data. The config will be synced to clients in the
top-level ''account_data''." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The id of the user to set account_data for. The access token must be
authorized to make requests for this user id. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}type${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The event type of the account_data to set. Custom types should be
namespaced to avoid clashes. ${YELLOW}Specify as: type=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The content of the account_data" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The account_data was successfully added.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setAccountDataForRoom operation
#
##############################################################################
print_setAccountDataForRoom_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setAccountDataForRoom - Set some account_data for the user.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "Set some account_data for the client on a given room. This config is only
visible to the user that set the account_data. The config will be synced to
clients in the per-room ''account_data''." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The id of the user to set account_data for. The access token must be
authorized to make requests for this user id. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}roomId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The id of the room to set account_data on. ${YELLOW}Specify as: roomId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}type${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The event type of the account_data to set. Custom types should be
namespaced to avoid clashes. ${YELLOW}Specify as: type=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The content of the account_data" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The account_data was successfully added.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setAvatar operation
#
##############################################################################
print_setAvatar_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setAvatar - Set the user's avatar URL.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API sets the given user's avatar URL. You must have permission to
set this user's avatar URL, e.g. you need to have their ''access_token''." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user whose avatar URL to set. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The avatar url info." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The avatar URL was set.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for setDisplayName operation
#
##############################################################################
print_setDisplayName_help() {
    echo ""
    echo -e "${BOLD}${WHITE}setDisplayName - Set the user's display name.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API sets the given user's display name. You must have permission to
set this user's display name, e.g. you need to have their ''access_token''." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo -e "${BOLD}${WHITE}Parameters${OFF}"
    echo -e "  * ${GREEN}userId${OFF} ${BLUE}[String]${OFF} ${RED}(required)${OFF}${OFF} - The user whose display name to set. ${YELLOW}Specify as: userId=value${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e "  * ${GREEN}body${OFF} ${BLUE}[application/json]${OFF} ${RED}(required)${OFF}${OFF} - The display name info." | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The display name was set.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}
##############################################################################
#
# Print help for getTurnCredentials operation
#
##############################################################################
print_getTurnCredentials_help() {
    echo ""
    echo -e "${BOLD}${WHITE}getTurnCredentials - Obtain TURN server credentials.${OFF}${BLUE}(AUTH - QUERY)${OFF}" | paste -sd' ' | fold -sw 80 | sed '2,$s/^/    /'
    echo -e ""
    echo -e "This API provides credentials for the client to use when initiating calls." | paste -sd' ' | fold -sw 80
    echo -e ""
    echo ""
    echo -e "${BOLD}${WHITE}Responses${OFF}"
    code=200
    echo -e "${result_color_table[${code:0:1}]}  200;The TURN server credentials.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
    code=429
    echo -e "${result_color_table[${code:0:1}]}  429;This request was rate-limited.${OFF}" | paste -sd' ' | column -t -s ';' | fold -sw 80 | sed '2,$s/^/       /'
}


##############################################################################
#
# Call casRedirect operation
#
##############################################################################
call_casRedirect() {
    local path_parameter_names=()
    local query_parameter_names=(redirectUrl)
    local path

    path=$(build_request_path "/_matrix/client/r0/login/cas/redirect" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call casTicket operation
#
##############################################################################
call_casTicket() {
    local path_parameter_names=()
    local query_parameter_names=(redirectUrl ticket)
    local path

    path=$(build_request_path "/_matrix/client/r0/login/cas/ticket" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call deleteDevice operation
#
##############################################################################
call_deleteDevice() {
    local path_parameter_names=(deviceId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/devices/{deviceId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="DELETE"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call getDevice operation
#
##############################################################################
call_getDevice() {
    local path_parameter_names=(deviceId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/devices/{deviceId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getDevices operation
#
##############################################################################
call_getDevices() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/devices" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call updateDevice operation
#
##############################################################################
call_updateDevice() {
    local path_parameter_names=(deviceId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/devices/{deviceId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call claimKeys operation
#
##############################################################################
call_claimKeys() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/keys/claim" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call downloadKeys operation
#
##############################################################################
call_downloadKeys() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/keys/query" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call getChangedKeys operation
#
##############################################################################
call_getChangedKeys() {
    local path_parameter_names=()
    local query_parameter_names=(from to access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/keys/changes" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call uploadKeys operation
#
##############################################################################
call_uploadKeys() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/keys/upload" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call downloadMedia operation
#
##############################################################################
call_downloadMedia() {
    local path_parameter_names=(serverName mediaId)
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/media/r0/download/{serverName}/{mediaId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call downloadMediaFile operation
#
##############################################################################
call_downloadMediaFile() {
    local path_parameter_names=(serverName mediaId fileName)
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/media/r0/download/{serverName}/{mediaId}/{fileName}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call downloadMediaThumbnail operation
#
##############################################################################
call_downloadMediaThumbnail() {
    local path_parameter_names=(serverName mediaId)
    local query_parameter_names=(width height method)
    local path

    path=$(build_request_path "/_matrix/media/r0/thumbnail/{serverName}/{mediaId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call uploadMedia operation
#
##############################################################################
call_uploadMedia() {
    local path_parameter_names=()
    local query_parameter_names=(filename)
    local path

    path=$(build_request_path "/_matrix/media/r0/upload" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call getPresenceList operation
#
##############################################################################
call_getPresenceList() {
    local path_parameter_names=(userId)
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/presence/list/{userId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getPresenceStatus operation
#
##############################################################################
call_getPresenceStatus() {
    local path_parameter_names=(userId)
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/presence/{userId}/status" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call setPresenceList operation
#
##############################################################################
call_setPresenceList() {
    local path_parameter_names=(userId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/presence/list/{userId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call setPresenceStatus operation
#
##############################################################################
call_setPresenceStatus() {
    local path_parameter_names=(userId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/presence/{userId}/status" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call deletePushRule operation
#
##############################################################################
call_deletePushRule() {
    local path_parameter_names=(scope kind ruleId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="DELETE"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getNotifications operation
#
##############################################################################
call_getNotifications() {
    local path_parameter_names=()
    local query_parameter_names=(from limit only access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/notifications" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getPushRule operation
#
##############################################################################
call_getPushRule() {
    local path_parameter_names=(scope kind ruleId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getPushRuleActions operation
#
##############################################################################
call_getPushRuleActions() {
    local path_parameter_names=(scope kind ruleId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/actions" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getPushRules operation
#
##############################################################################
call_getPushRules() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/pushrules/" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getPushers operation
#
##############################################################################
call_getPushers() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/pushers" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call isPushRuleEnabled operation
#
##############################################################################
call_isPushRuleEnabled() {
    local path_parameter_names=(scope kind ruleId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/enabled" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call modifyPushRule operation
#
##############################################################################
call_modifyPushRule() {
    local path_parameter_names=(scope kind ruleId)
    local query_parameter_names=(before after access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call setPushRuleActions operation
#
##############################################################################
call_setPushRuleActions() {
    local path_parameter_names=(scope kind ruleId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/actions" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call setPushRuleStatus operation
#
##############################################################################
call_setPushRuleStatus() {
    local path_parameter_names=(scope kind ruleId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/pushrules/{scope}/{kind}/{ruleId}/enabled" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call setPushers operation
#
##############################################################################
call_setPushers() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/pushers/set" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call createRoom operation
#
##############################################################################
call_createRoom() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/createRoom" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call createRoomAlias operation
#
##############################################################################
call_createRoomAlias() {
    local path_parameter_names=(roomAlias)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/directory/room/{roomAlias}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call deleteRoomAlias operation
#
##############################################################################
call_deleteRoomAlias() {
    local path_parameter_names=(roomAlias)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/directory/room/{roomAlias}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="DELETE"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getRoomId operation
#
##############################################################################
call_getRoomId() {
    local path_parameter_names=(roomAlias)
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/directory/room/{roomAlias}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call filterPublicRooms operation
#
##############################################################################
call_filterPublicRooms() {
    local path_parameter_names=()
    local query_parameter_names=(server access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/publicRooms" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call listPublicRooms operation
#
##############################################################################
call_listPublicRooms() {
    local path_parameter_names=()
    local query_parameter_names=(limit since server)
    local path

    path=$(build_request_path "/_matrix/client/r0/publicRooms" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call roomBanUser operation
#
##############################################################################
call_roomBanUser() {
    local path_parameter_names=(roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/ban" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call roomForget operation
#
##############################################################################
call_roomForget() {
    local path_parameter_names=(roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/forget" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call roomInvite operation
#
##############################################################################
call_roomInvite() {
    local path_parameter_names=(roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/invite" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call roomInviteUser operation
#
##############################################################################
call_roomInviteUser() {
    local path_parameter_names=(roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/invite " path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call roomJoin operation
#
##############################################################################
call_roomJoin() {
    local path_parameter_names=(roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/join" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call roomJoinByAlias operation
#
##############################################################################
call_roomJoinByAlias() {
    local path_parameter_names=(roomIdOrAlias)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/join/{roomIdOrAlias}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call roomKickUser operation
#
##############################################################################
call_roomKickUser() {
    local path_parameter_names=(roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/kick" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call roomLeave operation
#
##############################################################################
call_roomLeave() {
    local path_parameter_names=(roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/leave" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call roomUnbanUser operation
#
##############################################################################
call_roomUnbanUser() {
    local path_parameter_names=(roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/unban" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call createFilter operation
#
##############################################################################
call_createFilter() {
    local path_parameter_names=(userId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/user/{userId}/filter" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call getAllRoomStates operation
#
##############################################################################
call_getAllRoomStates() {
    local path_parameter_names=(roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/state" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getEvent operation
#
##############################################################################
call_getEvent() {
    local path_parameter_names=(eventId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/events/{eventId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getEventWithContext operation
#
##############################################################################
call_getEventWithContext() {
    local path_parameter_names=(roomId eventId)
    local query_parameter_names=(limit access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/context/{eventId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getFilter operation
#
##############################################################################
call_getFilter() {
    local path_parameter_names=(userId filterId)
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/user/{userId}/filter/{filterId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getRoomMembers operation
#
##############################################################################
call_getRoomMembers() {
    local path_parameter_names=(roomId)
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/members" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getRoomState operation
#
##############################################################################
call_getRoomState() {
    local path_parameter_names=(roomId eventType)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/state/{eventType}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getRoomStateWithKey operation
#
##############################################################################
call_getRoomStateWithKey() {
    local path_parameter_names=(roomId eventType stateKey)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/state/{eventType}/{stateKey}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call initialSync operation
#
##############################################################################
call_initialSync() {
    local path_parameter_names=()
    local query_parameter_names=(limit archived access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/initialSync" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call listEvents operation
#
##############################################################################
call_listEvents() {
    local path_parameter_names=(roomId)
    local query_parameter_names=(from to dir limit filter access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/messages" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call listenForEvents operation
#
##############################################################################
call_listenForEvents() {
    local path_parameter_names=()
    local query_parameter_names=(from timeout room_id access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/events" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call roomInitialSync operation
#
##############################################################################
call_roomInitialSync() {
    local path_parameter_names=(roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/initialSync" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call sendEvent operation
#
##############################################################################
call_sendEvent() {
    local path_parameter_names=(roomId eventType txnId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/send/{eventType}/{txnId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call sendReceipt operation
#
##############################################################################
call_sendReceipt() {
    local path_parameter_names=(roomId receiptType eventId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/receipt/{receiptType}/{eventId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call setRoomState operation
#
##############################################################################
call_setRoomState() {
    local path_parameter_names=(roomId eventType)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/state/{eventType}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call setRoomStateWithKey operation
#
##############################################################################
call_setRoomStateWithKey() {
    local path_parameter_names=(roomId eventType stateKey)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/state/{eventType}/{stateKey}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call setTypingState operation
#
##############################################################################
call_setTypingState() {
    local path_parameter_names=(userId roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/typing/{userId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call stripEvent operation
#
##############################################################################
call_stripEvent() {
    local path_parameter_names=(roomId eventId txnId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/rooms/{roomId}/redact/{eventId}/{txnId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call sync operation
#
##############################################################################
call_sync() {
    local path_parameter_names=()
    local query_parameter_names=(filter since full_state set_presence timeout access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/sync" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call search operation
#
##############################################################################
call_search() {
    local path_parameter_names=()
    local query_parameter_names=(next_batch access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/search" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call sendToDevice operation
#
##############################################################################
call_sendToDevice() {
    local path_parameter_names=(eventType txnId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/sendToDevice/{eventType}/{txnId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call versions operation
#
##############################################################################
call_versions() {
    local path_parameter_names=()
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/versions" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call whoIs operation
#
##############################################################################
call_whoIs() {
    local path_parameter_names=(userId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/admin/whois/{userId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call login operation
#
##############################################################################
call_login() {
    local path_parameter_names=()
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/login" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call logout operation
#
##############################################################################
call_logout() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/logout" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call addCredentials operation
#
##############################################################################
call_addCredentials() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/account/3pid" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call addUserTag operation
#
##############################################################################
call_addUserTag() {
    local path_parameter_names=(userId roomId tag)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/user/{userId}/rooms/{roomId}/tags/{tag}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call changePassword operation
#
##############################################################################
call_changePassword() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/account/password" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call deactivateAccount operation
#
##############################################################################
call_deactivateAccount() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/account/deactivate" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call deleteUserTag operation
#
##############################################################################
call_deleteUserTag() {
    local path_parameter_names=(userId roomId tag)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/user/{userId}/rooms/{roomId}/tags/{tag}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="DELETE"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getAvatar operation
#
##############################################################################
call_getAvatar() {
    local path_parameter_names=(userId)
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/profile/{userId}/avatar_url" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getDisplayName operation
#
##############################################################################
call_getDisplayName() {
    local path_parameter_names=(userId)
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/profile/{userId}/displayname" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getUserIdentifiers operation
#
##############################################################################
call_getUserIdentifiers() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/account/3pid" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getUserProfile operation
#
##############################################################################
call_getUserProfile() {
    local path_parameter_names=(userId)
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/profile/{userId}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call getUserTags operation
#
##############################################################################
call_getUserTags() {
    local path_parameter_names=(userId roomId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/user/{userId}/rooms/{roomId}/tags" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call registerAccount operation
#
##############################################################################
call_registerAccount() {
    local path_parameter_names=()
    local query_parameter_names=(kind)
    local path

    path=$(build_request_path "/_matrix/client/r0/register" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call requestEmailValidation operation
#
##############################################################################
call_requestEmailValidation() {
    local path_parameter_names=()
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/register/email/requestToken" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call requestEmailValidationAfterAdd operation
#
##############################################################################
call_requestEmailValidationAfterAdd() {
    local path_parameter_names=()
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/account/3pid/email/requestToken" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call requestPasswordReset operation
#
##############################################################################
call_requestPasswordReset() {
    local path_parameter_names=()
    local query_parameter_names=()
    local path

    path=$(build_request_path "/_matrix/client/r0/account/password/email/requestToken" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="POST"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}

##############################################################################
#
# Call setAccountData operation
#
##############################################################################
call_setAccountData() {
    local path_parameter_names=(userId type)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/user/{userId}/account_data/{type}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call setAccountDataForRoom operation
#
##############################################################################
call_setAccountDataForRoom() {
    local path_parameter_names=(userId roomId type)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/user/{userId}/rooms/{roomId}/account_data/{type}" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call setAvatar operation
#
##############################################################################
call_setAvatar() {
    local path_parameter_names=(userId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/profile/{userId}/avatar_url" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call setDisplayName operation
#
##############################################################################
call_setDisplayName() {
    local path_parameter_names=(userId)
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/profile/{userId}/displayname" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="PUT"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    local body_json_curl=""

    #
    # Check if the user provided 'Content-type' headers in the
    # command line. If not try to set them based on the Swagger specification
    # if values produces and consumes are defined unambigously
    #
    if [[ -z $header_content_type ]]; then
        header_content_type="application/json"
    fi


    if [[ -z $header_content_type && "$force" = false ]]; then
        :
        echo "ERROR: Request's content-type not specified!!!"
        echo "This operation expects content-type in one of the following formats:"
        echo -e "\t- application/json"
        echo ""
        echo "Use '--content-type' to set proper content type"
        exit 1
    else
        headers_curl="${headers_curl} -H 'Content-type: ${header_content_type}'"
    fi


    #
    # If we have received some body content over pipe, pass it from the
    # temporary file to cURL
    #
    if [[ -n $body_content_temp_file ]]; then
        if [[ "$print_curl" = true ]]; then
            echo "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        else
            eval "cat ${body_content_temp_file} | curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\" -d @-"
        fi
        rm "${body_content_temp_file}"
    #
    # If not, try to build the content body from arguments KEY==VALUE and KEY:=VALUE
    #
    else
        body_json_curl=$(body_parameters_to_json)
        if [[ "$print_curl" = true ]]; then
            echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        else
            eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} ${body_json_curl} \"${host}${path}\""
        fi
    fi
}

##############################################################################
#
# Call getTurnCredentials operation
#
##############################################################################
call_getTurnCredentials() {
    local path_parameter_names=()
    local query_parameter_names=( access_token )
    local path

    path=$(build_request_path "/_matrix/client/r0/voip/turnServer" path_parameter_names query_parameter_names)
    if [ $? -ne 0 ]; then
        ERROR_MSG=$path
        exit 1
    fi
    local method="GET"
    local headers_curl=$(header_arguments_to_curl)
    if [[ -n $header_accept ]]; then
        headers_curl="${headers_curl} -H 'Accept: ${header_accept}'"
    fi

    local basic_auth_option=""
    if [[ -n $basic_auth_credential ]]; then
        basic_auth_option="-u ${basic_auth_credential}"
    fi
    if [[ "$print_curl" = true ]]; then
        echo "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    else
        eval "curl ${basic_auth_option} ${curl_arguments} ${headers_curl} -X ${method} \"${host}${path}\""
    fi
}



##############################################################################
#
# Main
#
##############################################################################


# Check dependencies
type curl >/dev/null 2>&1 || { echo >&2 "ERROR: You do not have 'cURL' installed."; exit 1; }
type sed >/dev/null 2>&1 || { echo >&2 "ERROR: You do not have 'sed' installed."; exit 1; }
type column >/dev/null 2>&1 || { echo >&2 "ERROR: You do not have 'bsdmainutils' installed."; exit 1; }

#
# Process command line
#
# Pass all arguemnts before 'operation' to cURL except the ones we override
#
take_user=false
take_host=false
take_accept_header=false
take_contenttype_header=false

for key in "$@"; do
# Take the value of -u|--user argument
if [[ "$take_user" = true ]]; then
    basic_auth_credential="$key"
    take_user=false
    continue
fi
# Take the value of --host argument
if [[ "$take_host" = true ]]; then
    host="$key"
    take_host=false
    continue
fi
# Take the value of --accept argument
if [[ "$take_accept_header" = true ]]; then
    header_accept=$(lookup_mime_type "$key")
    take_accept_header=false
    continue
fi
# Take the value of --content-type argument
if [[ "$take_contenttype_header" = true ]]; then
    header_content_type=$(lookup_mime_type "$key")
    take_contenttype_header=false
    continue
fi
case $key in
    -h|--help)
    if [[ "x$operation" == "x" ]]; then
        print_help
        exit 0
    else
        eval "print_${operation}_help"
        exit 0
    fi
    ;;
    -V|--version)
    print_version
    exit 0
    ;;
    --about)
    print_about
    exit 0
    ;;
    -u|--user)
    take_user=true
    ;;
    --host)
    take_host=true
    ;;
    --force)
    force=true
    ;;
    -ac|--accept)
    take_accept_header=true
    ;;
    -ct|--content-type)
    take_contenttype_header=true
    ;;
    --dry-run)
    print_curl=true
    ;;
    -nc|--no-colors)
        RED=""
        GREEN=""
        YELLOW=""
        BLUE=""
        MAGENTA=""
        CYAN=""
        WHITE=""
        BOLD=""
        OFF=""
        result_color_table=( "" "" "" "" "" "" "" )
    ;;
    casRedirect)
    operation="casRedirect"
    ;;
    casTicket)
    operation="casTicket"
    ;;
    deleteDevice)
    operation="deleteDevice"
    ;;
    getDevice)
    operation="getDevice"
    ;;
    getDevices)
    operation="getDevices"
    ;;
    updateDevice)
    operation="updateDevice"
    ;;
    claimKeys)
    operation="claimKeys"
    ;;
    downloadKeys)
    operation="downloadKeys"
    ;;
    getChangedKeys)
    operation="getChangedKeys"
    ;;
    uploadKeys)
    operation="uploadKeys"
    ;;
    downloadMedia)
    operation="downloadMedia"
    ;;
    downloadMediaFile)
    operation="downloadMediaFile"
    ;;
    downloadMediaThumbnail)
    operation="downloadMediaThumbnail"
    ;;
    uploadMedia)
    operation="uploadMedia"
    ;;
    getPresenceList)
    operation="getPresenceList"
    ;;
    getPresenceStatus)
    operation="getPresenceStatus"
    ;;
    setPresenceList)
    operation="setPresenceList"
    ;;
    setPresenceStatus)
    operation="setPresenceStatus"
    ;;
    deletePushRule)
    operation="deletePushRule"
    ;;
    getNotifications)
    operation="getNotifications"
    ;;
    getPushRule)
    operation="getPushRule"
    ;;
    getPushRuleActions)
    operation="getPushRuleActions"
    ;;
    getPushRules)
    operation="getPushRules"
    ;;
    getPushers)
    operation="getPushers"
    ;;
    isPushRuleEnabled)
    operation="isPushRuleEnabled"
    ;;
    modifyPushRule)
    operation="modifyPushRule"
    ;;
    setPushRuleActions)
    operation="setPushRuleActions"
    ;;
    setPushRuleStatus)
    operation="setPushRuleStatus"
    ;;
    setPushers)
    operation="setPushers"
    ;;
    createRoom)
    operation="createRoom"
    ;;
    createRoomAlias)
    operation="createRoomAlias"
    ;;
    deleteRoomAlias)
    operation="deleteRoomAlias"
    ;;
    getRoomId)
    operation="getRoomId"
    ;;
    filterPublicRooms)
    operation="filterPublicRooms"
    ;;
    listPublicRooms)
    operation="listPublicRooms"
    ;;
    roomBanUser)
    operation="roomBanUser"
    ;;
    roomForget)
    operation="roomForget"
    ;;
    roomInvite)
    operation="roomInvite"
    ;;
    roomInviteUser)
    operation="roomInviteUser"
    ;;
    roomJoin)
    operation="roomJoin"
    ;;
    roomJoinByAlias)
    operation="roomJoinByAlias"
    ;;
    roomKickUser)
    operation="roomKickUser"
    ;;
    roomLeave)
    operation="roomLeave"
    ;;
    roomUnbanUser)
    operation="roomUnbanUser"
    ;;
    createFilter)
    operation="createFilter"
    ;;
    getAllRoomStates)
    operation="getAllRoomStates"
    ;;
    getEvent)
    operation="getEvent"
    ;;
    getEventWithContext)
    operation="getEventWithContext"
    ;;
    getFilter)
    operation="getFilter"
    ;;
    getRoomMembers)
    operation="getRoomMembers"
    ;;
    getRoomState)
    operation="getRoomState"
    ;;
    getRoomStateWithKey)
    operation="getRoomStateWithKey"
    ;;
    initialSync)
    operation="initialSync"
    ;;
    listEvents)
    operation="listEvents"
    ;;
    listenForEvents)
    operation="listenForEvents"
    ;;
    roomInitialSync)
    operation="roomInitialSync"
    ;;
    sendEvent)
    operation="sendEvent"
    ;;
    sendReceipt)
    operation="sendReceipt"
    ;;
    setRoomState)
    operation="setRoomState"
    ;;
    setRoomStateWithKey)
    operation="setRoomStateWithKey"
    ;;
    setTypingState)
    operation="setTypingState"
    ;;
    stripEvent)
    operation="stripEvent"
    ;;
    sync)
    operation="sync"
    ;;
    search)
    operation="search"
    ;;
    sendToDevice)
    operation="sendToDevice"
    ;;
    versions)
    operation="versions"
    ;;
    whoIs)
    operation="whoIs"
    ;;
    login)
    operation="login"
    ;;
    logout)
    operation="logout"
    ;;
    addCredentials)
    operation="addCredentials"
    ;;
    addUserTag)
    operation="addUserTag"
    ;;
    changePassword)
    operation="changePassword"
    ;;
    deactivateAccount)
    operation="deactivateAccount"
    ;;
    deleteUserTag)
    operation="deleteUserTag"
    ;;
    getAvatar)
    operation="getAvatar"
    ;;
    getDisplayName)
    operation="getDisplayName"
    ;;
    getUserIdentifiers)
    operation="getUserIdentifiers"
    ;;
    getUserProfile)
    operation="getUserProfile"
    ;;
    getUserTags)
    operation="getUserTags"
    ;;
    registerAccount)
    operation="registerAccount"
    ;;
    requestEmailValidation)
    operation="requestEmailValidation"
    ;;
    requestEmailValidationAfterAdd)
    operation="requestEmailValidationAfterAdd"
    ;;
    requestPasswordReset)
    operation="requestPasswordReset"
    ;;
    setAccountData)
    operation="setAccountData"
    ;;
    setAccountDataForRoom)
    operation="setAccountDataForRoom"
    ;;
    setAvatar)
    operation="setAvatar"
    ;;
    setDisplayName)
    operation="setDisplayName"
    ;;
    getTurnCredentials)
    operation="getTurnCredentials"
    ;;
    *==*)
    # Parse body arguments and convert them into top level
    # JSON properties passed in the body content as strings
    if [[ "$operation" ]]; then
        IFS='==' read body_key sep body_value <<< "$key"
        body_parameters[${body_key}]="\"${body_value}\""
    fi
    ;;
    *:=*)
    # Parse body arguments and convert them into top level
    # JSON properties passed in the body content without qoutes
    if [[ "$operation" ]]; then
        IFS=':=' read body_key sep body_value <<< "$key"
        body_parameters[${body_key}]=${body_value}
    fi
    ;;
    +([^=]):*)
    # Parse header arguments and convert them into curl
    # only after the operation argument
    if [[ "$operation" ]]; then
        IFS=':' read header_name header_value <<< "$key"
        header_arguments[$header_name]=$header_value
    else
        curl_arguments+=" $key"
    fi
    ;;
    -)
    body_content_temp_file=$(mktemp)
    cat - > $body_content_temp_file
    ;;
    *=*)
    # Parse operation arguments and convert them into curl
    # only after the operation argument
    if [[ "$operation" ]]; then
        IFS='=' read parameter_name parameter_value <<< "$key"
        if [[ -z "${operation_parameters[$parameter_name]+foo}" ]]; then
            operation_parameters[$parameter_name]=$(url_escape "${parameter_value}")
        else
            operation_parameters[$parameter_name]+=":::"$(url_escape "${parameter_value}")
        fi
    else
        curl_arguments+=" $key"
    fi
    ;;
    *)
    # If we are before the operation, treat the arguments as cURL arguments
    if [[ "x$operation" == "x" ]]; then
        # Maintain quotes around cURL arguments if necessary
        space_regexp="[[:space:]]"
        if [[ $key =~ $space_regexp ]]; then
            curl_arguments+=" \"$key\""
        else
            curl_arguments+=" $key"
        fi
    fi
    ;;
esac
done


# Check if user provided host name
if [[ -z "$host" ]]; then
    ERROR_MSG="ERROR: No hostname provided!!! Define env variable MATRIX_HOST like 'export MATRIX_HOST=...' or provide on command line option '--host ...'"
    exit 1
fi

# Check if user specified operation ID
if [[ -z "$operation" ]]; then
    ERROR_MSG="ERROR: No operation specified!!!"
    exit 1
fi


# Run cURL command based on the operation ID
case $operation in
    casRedirect)
    call_casRedirect
    ;;
    casTicket)
    call_casTicket
    ;;
    deleteDevice)
    call_deleteDevice
    ;;
    getDevice)
    call_getDevice
    ;;
    getDevices)
    call_getDevices
    ;;
    updateDevice)
    call_updateDevice
    ;;
    claimKeys)
    call_claimKeys
    ;;
    downloadKeys)
    call_downloadKeys
    ;;
    getChangedKeys)
    call_getChangedKeys
    ;;
    uploadKeys)
    call_uploadKeys
    ;;
    downloadMedia)
    call_downloadMedia
    ;;
    downloadMediaFile)
    call_downloadMediaFile
    ;;
    downloadMediaThumbnail)
    call_downloadMediaThumbnail
    ;;
    uploadMedia)
    call_uploadMedia
    ;;
    getPresenceList)
    call_getPresenceList
    ;;
    getPresenceStatus)
    call_getPresenceStatus
    ;;
    setPresenceList)
    call_setPresenceList
    ;;
    setPresenceStatus)
    call_setPresenceStatus
    ;;
    deletePushRule)
    call_deletePushRule
    ;;
    getNotifications)
    call_getNotifications
    ;;
    getPushRule)
    call_getPushRule
    ;;
    getPushRuleActions)
    call_getPushRuleActions
    ;;
    getPushRules)
    call_getPushRules
    ;;
    getPushers)
    call_getPushers
    ;;
    isPushRuleEnabled)
    call_isPushRuleEnabled
    ;;
    modifyPushRule)
    call_modifyPushRule
    ;;
    setPushRuleActions)
    call_setPushRuleActions
    ;;
    setPushRuleStatus)
    call_setPushRuleStatus
    ;;
    setPushers)
    call_setPushers
    ;;
    createRoom)
    call_createRoom
    ;;
    createRoomAlias)
    call_createRoomAlias
    ;;
    deleteRoomAlias)
    call_deleteRoomAlias
    ;;
    getRoomId)
    call_getRoomId
    ;;
    filterPublicRooms)
    call_filterPublicRooms
    ;;
    listPublicRooms)
    call_listPublicRooms
    ;;
    roomBanUser)
    call_roomBanUser
    ;;
    roomForget)
    call_roomForget
    ;;
    roomInvite)
    call_roomInvite
    ;;
    roomInviteUser)
    call_roomInviteUser
    ;;
    roomJoin)
    call_roomJoin
    ;;
    roomJoinByAlias)
    call_roomJoinByAlias
    ;;
    roomKickUser)
    call_roomKickUser
    ;;
    roomLeave)
    call_roomLeave
    ;;
    roomUnbanUser)
    call_roomUnbanUser
    ;;
    createFilter)
    call_createFilter
    ;;
    getAllRoomStates)
    call_getAllRoomStates
    ;;
    getEvent)
    call_getEvent
    ;;
    getEventWithContext)
    call_getEventWithContext
    ;;
    getFilter)
    call_getFilter
    ;;
    getRoomMembers)
    call_getRoomMembers
    ;;
    getRoomState)
    call_getRoomState
    ;;
    getRoomStateWithKey)
    call_getRoomStateWithKey
    ;;
    initialSync)
    call_initialSync
    ;;
    listEvents)
    call_listEvents
    ;;
    listenForEvents)
    call_listenForEvents
    ;;
    roomInitialSync)
    call_roomInitialSync
    ;;
    sendEvent)
    call_sendEvent
    ;;
    sendReceipt)
    call_sendReceipt
    ;;
    setRoomState)
    call_setRoomState
    ;;
    setRoomStateWithKey)
    call_setRoomStateWithKey
    ;;
    setTypingState)
    call_setTypingState
    ;;
    stripEvent)
    call_stripEvent
    ;;
    sync)
    call_sync
    ;;
    search)
    call_search
    ;;
    sendToDevice)
    call_sendToDevice
    ;;
    versions)
    call_versions
    ;;
    whoIs)
    call_whoIs
    ;;
    login)
    call_login
    ;;
    logout)
    call_logout
    ;;
    addCredentials)
    call_addCredentials
    ;;
    addUserTag)
    call_addUserTag
    ;;
    changePassword)
    call_changePassword
    ;;
    deactivateAccount)
    call_deactivateAccount
    ;;
    deleteUserTag)
    call_deleteUserTag
    ;;
    getAvatar)
    call_getAvatar
    ;;
    getDisplayName)
    call_getDisplayName
    ;;
    getUserIdentifiers)
    call_getUserIdentifiers
    ;;
    getUserProfile)
    call_getUserProfile
    ;;
    getUserTags)
    call_getUserTags
    ;;
    registerAccount)
    call_registerAccount
    ;;
    requestEmailValidation)
    call_requestEmailValidation
    ;;
    requestEmailValidationAfterAdd)
    call_requestEmailValidationAfterAdd
    ;;
    requestPasswordReset)
    call_requestPasswordReset
    ;;
    setAccountData)
    call_setAccountData
    ;;
    setAccountDataForRoom)
    call_setAccountDataForRoom
    ;;
    setAvatar)
    call_setAvatar
    ;;
    setDisplayName)
    call_setDisplayName
    ;;
    getTurnCredentials)
    call_getTurnCredentials
    ;;
    *)
    ERROR_MSG="ERROR: Unknown operation: $operation"
    exit 1
esac
